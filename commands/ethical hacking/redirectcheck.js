import axios from 'axios';

export default {
  name: 'redirectcheck',
  alias: ['redirect', 'redirects'],
  description: 'Check HTTP redirect chain',
  category: 'ethical hacking',
  usage: 'redirectcheck <url>',
  async execute(sock, m, args, PREFIX) {
    const jid = m.key.remoteJid;
    if (!args[0]) {
      return sock.sendMessage(jid, { text: `â•­â”€âŒˆ ğŸ”€ *REDIRECT CHECKER* âŒ‹\nâ”‚\nâ”œâ”€âŠ· *${PREFIX}redirectcheck <url>*\nâ”‚  â””âŠ· Check HTTP redirect chain\nâ”‚\nâ”œâ”€âŠ· *Example:*\nâ”‚  â””âŠ· ${PREFIX}redirectcheck http://google.com\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n> *WOLFBOT*` }, { quoted: m });
    }
    await sock.sendMessage(jid, { react: { text: 'â³', key: m.key } });
    try {
      let target = args[0].trim();
      if (!/^https?:\/\//i.test(target)) target = 'http://' + target;

      const chain = [];
      let currentUrl = target;
      const maxRedirects = 10;

      for (let i = 0; i < maxRedirects; i++) {
        try {
          const res = await axios.get(currentUrl, {
            timeout: 10000,
            maxRedirects: 0,
            headers: { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36' },
            validateStatus: () => true
          });

          chain.push({
            step: i + 1,
            url: currentUrl,
            status: res.status,
            statusText: res.statusText,
            server: res.headers['server'] || '-',
            location: res.headers['location'] || null
          });

          if (res.status >= 300 && res.status < 400 && res.headers['location']) {
            let nextUrl = res.headers['location'];
            if (nextUrl.startsWith('/')) {
              const urlObj = new URL(currentUrl);
              nextUrl = urlObj.origin + nextUrl;
            } else if (!nextUrl.startsWith('http')) {
              const urlObj = new URL(currentUrl);
              nextUrl = urlObj.origin + '/' + nextUrl;
            }
            currentUrl = nextUrl;
          } else {
            break;
          }
        } catch (err) {
          chain.push({
            step: i + 1,
            url: currentUrl,
            status: 'Error',
            statusText: err.message,
            server: '-',
            location: null
          });
          break;
        }
      }

      const redirectCount = chain.filter(c => c.status >= 300 && c.status < 400).length;
      const finalUrl = chain[chain.length - 1]?.url || target;
      const finalStatus = chain[chain.length - 1]?.status || 'Unknown';

      let output = `â•­â”€âŒˆ ğŸ”€ *REDIRECT CHAIN ANALYSIS* âŒ‹\nâ”‚\nâ”œâ”€âŠ· *Initial URL:* ${target}\nâ”œâ”€âŠ· *Final URL:* ${finalUrl}\nâ”œâ”€âŠ· *Redirects:* ${redirectCount}\nâ”œâ”€âŠ· *Final Status:* ${finalStatus}\nâ”‚\n`;

      output += `â”œâ”€âŠ· ğŸ”— *Redirect Chain:*\nâ”‚\n`;

      chain.forEach((step, i) => {
        const statusIcon = step.status >= 200 && step.status < 300 ? 'âœ…' :
                           step.status >= 300 && step.status < 400 ? 'ğŸ”€' : 'âŒ';
        output += `â”œâ”€âŠ· ${statusIcon} *Step ${step.step}*\n`;
        output += `â”‚  â””âŠ· URL: ${step.url.length > 60 ? step.url.substring(0, 60) + '...' : step.url}\n`;
        output += `â”‚  â””âŠ· Status: ${step.status} ${step.statusText}\n`;
        if (step.server !== '-') output += `â”‚  â””âŠ· Server: ${step.server}\n`;
        if (step.location) output += `â”‚  â””âŠ· â†’ Redirects to: ${step.location.length > 50 ? step.location.substring(0, 50) + '...' : step.location}\n`;
        output += `â”‚\n`;
      });

      if (redirectCount === 0) {
        output += `â”œâ”€âŠ· âœ… No redirects detected\nâ”‚\n`;
      } else if (redirectCount > 3) {
        output += `â”œâ”€âŠ· âš ï¸ Too many redirects may\nâ”‚  â””âŠ· affect performance and SEO\nâ”‚\n`;
      }

      const httpToHttps = chain.some((c, i) => c.url.startsWith('http://') && chain[i + 1]?.url.startsWith('https://'));
      if (httpToHttps) {
        output += `â”œâ”€âŠ· ğŸ”’ HTTPâ†’HTTPS upgrade detected\nâ”‚\n`;
      }

      output += `â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n> *WOLFBOT*`;

      await sock.sendMessage(jid, { text: output }, { quoted: m });
      await sock.sendMessage(jid, { react: { text: 'âœ…', key: m.key } });
    } catch (err) {
      await sock.sendMessage(jid, { react: { text: 'âŒ', key: m.key } });
      await sock.sendMessage(jid, { text: `âŒ Error: ${err.message}` }, { quoted: m });
    }
  }
};
