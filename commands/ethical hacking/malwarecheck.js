import axios from 'axios';

export default {
  name: 'malwarecheck',
  alias: ['malware', 'viruscheck', 'urlcheck'],
  description: 'Check URL/domain for malware using threat databases',
  category: 'ethical hacking',
  usage: 'malwarecheck <url>',
  async execute(sock, m, args, PREFIX) {
    const jid = m.key.remoteJid;
    if (!args[0]) {
      return sock.sendMessage(jid, { text: `â•­â”€âŒˆ ğŸ” *MALWARE CHECKER* âŒ‹\nâ”‚\nâ”œâ”€âŠ· *${PREFIX}malwarecheck <url>*\nâ”‚  â””âŠ· Check URL against malware\nâ”‚     and threat databases\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n> *WOLFBOT*` }, { quoted: m });
    }
    await sock.sendMessage(jid, { react: { text: 'â³', key: m.key } });
    try {
      let url = args[0];
      if (!url.startsWith('http://') && !url.startsWith('https://')) {
        url = 'https://' + url;
      }

      const domain = url.replace(/^https?:\/\//, '').split('/')[0].split(':')[0];

      const checks = {
        urlhaus: { status: 'pending', result: null },
        virustotal: { status: 'pending', result: null },
        safeBrowsing: { status: 'pending', result: null }
      };

      try {
        const urlhausRes = await axios.post('https://urlhaus-api.abuse.ch/v1/url/', 
          `url=${encodeURIComponent(url)}`, {
          timeout: 10000,
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' }
        });

        if (urlhausRes.data) {
          checks.urlhaus.status = 'done';
          checks.urlhaus.result = urlhausRes.data;
        }
      } catch (e) {
        checks.urlhaus.status = 'error';
      }

      try {
        const urlhausHost = await axios.post('https://urlhaus-api.abuse.ch/v1/host/',
          `host=${encodeURIComponent(domain)}`, {
          timeout: 10000,
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' }
        });

        if (urlhausHost.data && urlhausHost.data.urls) {
          checks.safeBrowsing.status = 'done';
          checks.safeBrowsing.result = urlhausHost.data;
        }
      } catch (e) {
        checks.safeBrowsing.status = 'error';
      }

      try {
        const vtKey = process.env.VIRUSTOTAL_API_KEY || '';
        if (vtKey) {
          const vtRes = await axios.get(`https://www.virustotal.com/vtapi/v2/url/report`, {
            params: { apikey: vtKey, resource: url },
            timeout: 10000
          });
          checks.virustotal.status = 'done';
          checks.virustotal.result = vtRes.data;
        } else {
          checks.virustotal.status = 'skipped';
        }
      } catch (e) {
        checks.virustotal.status = 'error';
      }

      let threatLevel = 'ğŸŸ¢ Clean';
      let threatCount = 0;

      const urlhausData = checks.urlhaus.result;
      if (urlhausData && urlhausData.query_status === 'ok' && urlhausData.url_status) {
        threatCount++;
        threatLevel = 'ğŸ”´ Malicious';
      }

      const hostData = checks.safeBrowsing.result;
      let hostThreatCount = 0;
      if (hostData && hostData.urls && Array.isArray(hostData.urls)) {
        hostThreatCount = hostData.urls.filter(u => u.url_status === 'online').length;
        if (hostThreatCount > 0) {
          threatCount++;
          threatLevel = 'ğŸ”´ Malicious';
        }
      }

      const vtData = checks.virustotal.result;
      let vtPositives = 0;
      if (vtData && vtData.positives) {
        vtPositives = vtData.positives;
        if (vtPositives > 0) {
          threatCount++;
          threatLevel = vtPositives > 3 ? 'ğŸ”´ Malicious' : 'ğŸŸ¡ Suspicious';
        }
      }

      if (threatCount === 0) threatLevel = 'ğŸŸ¢ Clean';
      else if (threatCount === 1) threatLevel = 'ğŸŸ¡ Suspicious';
      else threatLevel = 'ğŸ”´ Malicious';

      let result = `â•­â”€âŒˆ ğŸ” *MALWARE CHECK RESULTS* âŒ‹\nâ”‚\n`;
      result += `â”œâ”€âŠ· *URL:* ${url.substring(0, 60)}${url.length > 60 ? '...' : ''}\n`;
      result += `â”œâ”€âŠ· *Domain:* ${domain}\n`;
      result += `â”œâ”€âŠ· *Threat Level:* ${threatLevel}\nâ”‚\n`;

      result += `â”œâ”€âŠ· *URLhaus Database:*\n`;
      if (checks.urlhaus.status === 'done') {
        if (urlhausData.query_status === 'ok' && urlhausData.url_status) {
          result += `â”‚  â”œâŠ· Status: ğŸ”´ ${urlhausData.url_status}\n`;
          result += `â”‚  â”œâŠ· Threat: ${urlhausData.threat || 'Unknown'}\n`;
          if (urlhausData.tags) result += `â”‚  â”œâŠ· Tags: ${urlhausData.tags}\n`;
          if (urlhausData.date_added) result += `â”‚  â””âŠ· Added: ${urlhausData.date_added}\n`;
        } else {
          result += `â”‚  â””âŠ· Status: âœ… Not found in database\n`;
        }
      } else {
        result += `â”‚  â””âŠ· Status: âš ï¸ Check unavailable\n`;
      }
      result += `â”‚\n`;

      result += `â”œâ”€âŠ· *Host Threat Intel:*\n`;
      if (checks.safeBrowsing.status === 'done' && hostData) {
        result += `â”‚  â”œâŠ· URLs tracked: ${hostData.urls_online || 0} online\n`;
        if (hostData.blacklists) {
          const bl = hostData.blacklists;
          result += `â”‚  â”œâŠ· Spamhaus: ${bl.spamhaus_dbl || 'Not listed'}\n`;
          result += `â”‚  â””âŠ· SURBL: ${bl.surbl || 'Not listed'}\n`;
        } else {
          result += `â”‚  â””âŠ· Threats: ${hostThreatCount > 0 ? `ğŸ”´ ${hostThreatCount} active` : 'âœ… None found'}\n`;
        }
      } else {
        result += `â”‚  â””âŠ· Status: âš ï¸ Check unavailable\n`;
      }
      result += `â”‚\n`;

      result += `â”œâ”€âŠ· *VirusTotal:*\n`;
      if (checks.virustotal.status === 'done' && vtData) {
        result += `â”‚  â”œâŠ· Detections: ${vtPositives}/${vtData.total || 0}\n`;
        result += `â”‚  â””âŠ· Scan date: ${vtData.scan_date || 'N/A'}\n`;
      } else if (checks.virustotal.status === 'skipped') {
        result += `â”‚  â””âŠ· âš ï¸ No API key (set VIRUSTOTAL_API_KEY)\n`;
      } else {
        result += `â”‚  â””âŠ· Status: âš ï¸ Check unavailable\n`;
      }
      result += `â”‚\n`;

      if (threatCount > 0) {
        result += `â”œâ”€âŠ· âš ï¸ *Warnings:*\n`;
        result += `â”‚  â”œâŠ· This URL has been flagged\n`;
        result += `â”‚  â”œâŠ· Do NOT visit or download from it\n`;
        result += `â”‚  â””âŠ· Report to your security team\n`;
      } else {
        result += `â”œâ”€âŠ· â„¹ï¸ *Note:*\n`;
        result += `â”‚  â””âŠ· No threats found, but always\nâ”‚     exercise caution with unknown URLs\n`;
      }
      result += `â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n> *WOLFBOT*`;

      await sock.sendMessage(jid, { text: result }, { quoted: m });
      await sock.sendMessage(jid, { react: { text: 'âœ…', key: m.key } });
    } catch (err) {
      await sock.sendMessage(jid, { react: { text: 'âŒ', key: m.key } });
      await sock.sendMessage(jid, { text: `âŒ Error: ${err.message}` }, { quoted: m });
    }
  }
};
