import fs from 'fs';
import path from 'path';

const antiAudioFile = './antiaudio.json';

// Ensure JSON file exists
if (!fs.existsSync(antiAudioFile)) {
    fs.writeFileSync(antiAudioFile, JSON.stringify([], null, 2));
}

// Load settings
function loadAntiAudio() {
    try {
        if (!fs.existsSync(antiAudioFile)) return [];
        const data = fs.readFileSync(antiAudioFile, 'utf8');
        return JSON.parse(data);
    } catch (error) {
        console.error('Error loading anti-audio settings:', error);
        return [];
    }
}

// Save settings
function saveAntiAudio(data) {
    try {
        fs.writeFileSync(antiAudioFile, JSON.stringify(data, null, 2));
    } catch (error) {
        console.error('Error saving anti-audio settings:', error);
    }
}

// Utility function to clean JID
function cleanJid(jid) {
    if (!jid) return jid;
    // Remove device suffix and ensure proper format
    const clean = jid.split(':')[0];
    return clean.includes('@') ? clean : clean + '@s.whatsapp.net';
}

// Setup listener once globally
let antiAudioListenerAttached = false;

export default {
    name: 'antiaudio',
    description: 'Control audio/voice message sharing in the group',
    category: 'group',
    async execute(sock, msg, args, metadata) {
        const chatId = msg.key.remoteJid;
        const isGroup = chatId.endsWith('@g.us');
        
        if (!isGroup) {
            return sock.sendMessage(chatId, { 
                text: '‚ùå This command can only be used in groups.' 
            }, { quoted: msg });
        }

        // Get sender's JID
        let sender = msg.key.participant || (msg.key.fromMe ? sock.user.id : msg.key.remoteJid);
        sender = cleanJid(sender);

        // Check if user is admin
        let isAdmin = false;
        let botIsAdmin = false;
        let botIsSuperAdmin = false;
        
        try {
            const groupMetadata = await sock.groupMetadata(chatId);
            const cleanSender = cleanJid(sender);
            
            // Check if sender is admin
            const participant = groupMetadata.participants.find(p => {
                const cleanParticipantJid = cleanJid(p.id);
                return cleanParticipantJid === cleanSender;
            });
            
            isAdmin = participant?.admin === 'admin' || participant?.admin === 'superadmin';
            
            // Check if bot is admin
            const botJid = cleanJid(sock.user?.id);
            const botParticipant = groupMetadata.participants.find(p => {
                const cleanParticipantJid = cleanJid(p.id);
                return cleanParticipantJid === botJid;
            });
            botIsAdmin = botParticipant?.admin === 'admin' || botParticipant?.admin === 'superadmin';
            botIsSuperAdmin = botParticipant?.admin === 'superadmin';
            
        } catch (error) {
            console.error('Error fetching group metadata:', error);
            return sock.sendMessage(chatId, { 
                text: '‚ùå Failed to fetch group information. Please try again.' 
            }, { quoted: msg });
        }

        // ONLY admins can use the command
        if (!isAdmin) {
            return sock.sendMessage(chatId, { 
                text: '‚ùå Only group admins can use this command!' 
            }, { quoted: msg });
        }

        const settings = loadAntiAudio();
        const groupIndex = settings.findIndex(g => g.chatId === chatId);
        const currentGroupSettings = groupIndex !== -1 ? settings[groupIndex] : null;

        const subCommand = args[0]?.toLowerCase();

        if (subCommand === 'on') {
            const mode = args[1]?.toLowerCase();
            
            if (!mode || !['warn', 'delete', 'kick'].includes(mode)) {
                return sock.sendMessage(chatId, { 
                    text: '‚ï≠‚îÄ‚åà ‚öôÔ∏è *ANTI-AUDIO SETUP* ‚åã\n‚îÇ\n‚îú‚îÄ‚ä∑ *.antiaudio on warn*\n‚îÇ  ‚îî‚ä∑ Warn senders\n‚îú‚îÄ‚ä∑ *.antiaudio on delete*\n‚îÇ  ‚îî‚ä∑ Auto-delete audio\n‚îú‚îÄ‚ä∑ *.antiaudio on kick*\n‚îÇ  ‚îî‚ä∑ Kick senders\n‚ï∞‚îÄ‚îÄ‚îÄ' 
                }, { quoted: msg });
            }

            // Parse audio types if specified
            const audioTypes = args.slice(2).map(t => t.toLowerCase()) || [];
            const defaultTypes = ['audio']; // Default to all audio
            const validTypes = ['audio', 'voice', 'music'];
            
            let selectedTypes = [];
            if (audioTypes.length > 0) {
                selectedTypes = audioTypes.filter(type => validTypes.includes(type));
            }
            if (selectedTypes.length === 0) {
                selectedTypes = defaultTypes;
            }

            // // Warn if bot is not admin for certain modes
            // if (!botIsAdmin && (mode === 'delete' || mode === 'kick')) {
            //     await sock.sendMessage(chatId, { 
            //         text: '‚ö†Ô∏è *Warning:* I need admin permissions for delete/kick modes!\n\nPlease make me an admin for these features to work properly.' 
            //     }, { quoted: msg });
            // }

            // Warn if bot is not superadmin for kick mode
            if (!botIsSuperAdmin && mode === 'kick') {
                await sock.sendMessage(chatId, { 
                    text: '‚ö†Ô∏è *Important:* I need *superadmin* permissions to kick members!\n\nPlease make me a superadmin for kick mode to work.' 
                }, { quoted: msg });
            }

            const newSettings = {
                chatId,
                enabled: true,
                mode: mode,
                audioTypes: selectedTypes,
                exemptAdmins: true,
                warningCount: {} // Track warnings per user
            };

            if (groupIndex !== -1) {
                settings[groupIndex] = newSettings;
            } else {
                settings.push(newSettings);
            }

            saveAntiAudio(settings);
            
            // Attach listener if not already attached
            if (!antiAudioListenerAttached) {
                setupAntiAudioListener(sock);
                antiAudioListenerAttached = true;
            }

            const modeDescriptions = {
                'warn': 'Users will receive warnings when sharing audio',
                'delete': 'Audio will be automatically deleted',
                'kick': 'Users will be kicked for sharing audio'
            };

            const typesText = selectedTypes.map(t => {
                if (t === 'audio') return '‚Ä¢ All audio messages';
                if (t === 'voice') return '‚Ä¢ Voice notes only';
                if (t === 'music') return '‚Ä¢ Music files only';
                return `‚Ä¢ ${t.charAt(0).toUpperCase() + t.slice(1)}`;
            }).join('\n');

            await sock.sendMessage(chatId, { 
                text: `‚úÖ *Anti-Audio enabled!*\n\nMode: *${mode.toUpperCase()}*\n` 
            }, { quoted: msg });

        } 
        else if (subCommand === 'off') {
            if (groupIndex !== -1) {
                settings.splice(groupIndex, 1);
                saveAntiAudio(settings);
                await sock.sendMessage(chatId, { 
                    text: '‚ùå *Anti-Audio disabled!*\n\nEveryone can now share audio in this group.' 
                }, { quoted: msg });
            } else {
                await sock.sendMessage(chatId, { 
                    text: '‚ÑπÔ∏è Anti-Audio is already disabled in this group.\nEveryone can share audio.' 
                }, { quoted: msg });
            }
        } 
        else if (subCommand === 'exemptadmins') {
            if (!currentGroupSettings || !currentGroupSettings.enabled) {
                return sock.sendMessage(chatId, { 
                    text: '‚ùå Anti-Audio is not enabled in this group.\nEnable it first with `.antiaudio on [mode]`' 
                }, { quoted: msg });
            }

            const toggle = args[1]?.toLowerCase();
            if (toggle === 'off') {
                currentGroupSettings.exemptAdmins = false;
                await sock.sendMessage(chatId, { 
                    text: '‚öôÔ∏è *Admin exemption disabled*\n\nAdmins will now be subject to anti-audio rules.' 
                }, { quoted: msg });
            } else if (toggle === 'on') {
                currentGroupSettings.exemptAdmins = true;
                await sock.sendMessage(chatId, { 
                    text: '‚öôÔ∏è *Admin exemption enabled*\n\nAdmins can now share audio freely.' 
                }, { quoted: msg });
            } else {
                const currentStatus = currentGroupSettings.exemptAdmins ? 'enabled' : 'disabled';
                await sock.sendMessage(chatId, { 
                    text: `‚öôÔ∏è *Admin Exemption Status*\n\nCurrently: *${currentStatus}*\n\nTo change:\n\`.antiaudio exemptadmins on\` - Enable\n\`.antiaudio exemptadmins off\` - Disable` 
                }, { quoted: msg });
            }
            
            settings[groupIndex] = currentGroupSettings;
            saveAntiAudio(settings);
        }
        else if (subCommand === 'types') {
            if (!currentGroupSettings || !currentGroupSettings.enabled) {
                return sock.sendMessage(chatId, { 
                    text: '‚ùå Anti-Audio is not enabled in this group.\nEnable it first with `.antiaudio on [mode]`' 
                }, { quoted: msg });
            }

            const action = args[1]?.toLowerCase();
            
            if (action === 'add') {
                const typesToAdd = args.slice(2).map(t => t.toLowerCase()).filter(t => 
                    ['audio', 'voice', 'music'].includes(t)
                );
                
                if (typesToAdd.length === 0) {
                    return sock.sendMessage(chatId, { 
                        text: '‚ï≠‚îÄ‚åà üéµ *ANTI-AUDIO TYPES* ‚åã\n‚îÇ\n‚îú‚îÄ‚ä∑ *.antiaudio types add audio*\n‚îÇ  ‚îî‚ä∑ All audio messages\n‚îú‚îÄ‚ä∑ *.antiaudio types add voice*\n‚îÇ  ‚îî‚ä∑ Voice notes only\n‚îú‚îÄ‚ä∑ *.antiaudio types add music*\n‚îÇ  ‚îî‚ä∑ Music files only\n‚ï∞‚îÄ‚îÄ‚îÄ' 
                    }, { quoted: msg });
                }
                
                const addedTypes = [];
                typesToAdd.forEach(type => {
                    if (!currentGroupSettings.audioTypes.includes(type)) {
                        currentGroupSettings.audioTypes.push(type);
                        addedTypes.push(type);
                    }
                });
                
                if (addedTypes.length > 0) {
                    settings[groupIndex] = currentGroupSettings;
                    saveAntiAudio(settings);
                    const typesDisplay = addedTypes.map(t => {
                        if (t === 'audio') return 'All audio messages';
                        if (t === 'voice') return 'Voice notes';
                        if (t === 'music') return 'Music files';
                        return t;
                    });
                    await sock.sendMessage(chatId, { 
                        text: `‚úÖ Added audio types:\n${typesDisplay.map(t => `‚Ä¢ ${t}`).join('\n')}\n\nNow blocking ${currentGroupSettings.audioTypes.length} audio types.` 
                    }, { quoted: msg });
                } else {
                    await sock.sendMessage(chatId, { 
                        text: '‚ö†Ô∏è All specified types are already being blocked.' 
                    }, { quoted: msg });
                }
            }
            else if (action === 'remove') {
                const typesToRemove = args.slice(2).map(t => t.toLowerCase());
                
                if (typesToRemove.length === 0) {
                    return sock.sendMessage(chatId, { 
                        text: '‚ï≠‚îÄ‚åà üéµ *ANTI-AUDIO TYPES REMOVE* ‚åã\n‚îÇ\n‚îú‚îÄ‚ä∑ *.antiaudio types remove [type]*\n‚îÇ  ‚îî‚ä∑ Remove audio type\n‚ï∞‚îÄ‚îÄ‚îÄ' 
                    }, { quoted: msg });
                }
                
                const removedTypes = [];
                typesToRemove.forEach(type => {
                    const index = currentGroupSettings.audioTypes.indexOf(type);
                    if (index > -1) {
                        currentGroupSettings.audioTypes.splice(index, 1);
                        removedTypes.push(type);
                    }
                });
                
                if (removedTypes.length > 0) {
                    settings[groupIndex] = currentGroupSettings;
                    saveAntiAudio(settings);
                    const typesDisplay = removedTypes.map(t => {
                        if (t === 'audio') return 'All audio messages';
                        if (t === 'voice') return 'Voice notes';
                        if (t === 'music') return 'Music files';
                        return t;
                    });
                    await sock.sendMessage(chatId, { 
                        text: `‚úÖ Removed audio types:\n${typesDisplay.map(t => `‚Ä¢ ${t}`).join('\n')}\n\nNow blocking ${currentGroupSettings.audioTypes.length} audio types.` 
                    }, { quoted: msg });
                } else {
                    await sock.sendMessage(chatId, { 
                        text: '‚ùå None of the specified types were being blocked.' 
                    }, { quoted: msg });
                }
            }
            else if (action === 'list') {
                const currentTypes = currentGroupSettings.audioTypes || [];
                if (currentTypes.length === 0) {
                    await sock.sendMessage(chatId, { 
                        text: 'üìã *Blocked Audio Types*\n\nNo audio types are currently blocked.\n\nAdd types with:\n`.antiaudio types add [type]`' 
                    }, { quoted: msg });
                } else {
                    let listText = 'üìã *Blocked Audio Types*\n\n';
                    currentTypes.forEach((type, index) => {
                        const displayName = type === 'audio' ? 'All audio messages' :
                                          type === 'voice' ? 'Voice notes' :
                                          type === 'music' ? 'Music files' : type;
                        listText += `${index + 1}. ${displayName}\n`;
                    });
                    listText += `\nTotal: ${currentTypes.length} types\n\nRemove types with:\n\`.antiaudio types remove [type]\``;
                    await sock.sendMessage(chatId, { text: listText }, { quoted: msg });
                }
            }
            else {
                await sock.sendMessage(chatId, { 
                    text: '‚ï≠‚îÄ‚åà üìã *ANTI-AUDIO TYPES* ‚åã\n‚îÇ\n‚îú‚îÄ‚ä∑ *.antiaudio types add [type]*\n‚îÇ  ‚îî‚ä∑ Add audio type\n‚îú‚îÄ‚ä∑ *.antiaudio types remove [type]*\n‚îÇ  ‚îî‚ä∑ Remove audio type\n‚îú‚îÄ‚ä∑ *.antiaudio types list*\n‚îÇ  ‚îî‚ä∑ View blocked types\n‚ï∞‚îÄ‚îÄ‚îÄ' 
                }, { quoted: msg });
            }
        }
        else if (subCommand === 'status') {
            if (currentGroupSettings) {
                const status = currentGroupSettings.enabled ? 
                    `‚úÖ ENABLED (${currentGroupSettings.mode.toUpperCase()} mode)` : 
                    '‚ùå DISABLED';
                
                const botStatus = botIsAdmin ? '‚úÖ I am admin' : '‚ùå I am NOT admin';
                const botSuperStatus = botIsSuperAdmin ? '‚úÖ I am superadmin' : '‚ùå I am NOT superadmin';
                
                let statusText = `üìä *Anti-Audio Status*\n\n`;
                statusText += `‚Ä¢ Feature: ${status}\n`;
                statusText += `‚Ä¢ Bot admin: ${botStatus}\n`;
                statusText += `‚Ä¢ Bot superadmin: ${botSuperStatus}\n\n`;
                
                if (currentGroupSettings.enabled) {
                    const audioTypesCount = currentGroupSettings.audioTypes?.length || 0;
                    const audioTypesText = currentGroupSettings.audioTypes?.map(t => {
                        if (t === 'audio') return 'All audio';
                        if (t === 'voice') return 'Voice notes';
                        if (t === 'music') return 'Music files';
                        return t;
                    }).join(', ') || 'None';
                    statusText += `‚Ä¢ Blocked audio types: ${audioTypesCount}\n`;
                    statusText += `‚Ä¢ Types: ${audioTypesText}\n`;
                    statusText += `‚Ä¢ Admins exempt: ${currentGroupSettings.exemptAdmins ? 'Yes' : 'No'}\n`;
                    
                    // Show warning counts if any
                    if (currentGroupSettings.warningCount && Object.keys(currentGroupSettings.warningCount).length > 0) {
                        statusText += `‚Ä¢ Users warned: ${Object.keys(currentGroupSettings.warningCount).length}\n`;
                    }
                }
                
                statusText += `\n*Detection:*\n‚Ä¢ Audio files (MP3, etc.)\n‚Ä¢ Voice notes/recordings\n‚Ä¢ Music files\n‚Ä¢ Audio with captions`;
                
                await sock.sendMessage(chatId, { text: statusText }, { quoted: msg });
            } else {
                await sock.sendMessage(chatId, { 
                    text: `üìä *Anti-Audio Status*\n\n‚ùå DISABLED\nEveryone can share audio.\n\n*To enable:*\n\`.antiaudio on [mode]\`\n\nModes: warn, delete, kick\n\nExample: \`.antiaudio on delete\`` 
                }, { quoted: msg });
            }
        }
        else {
            // Show help
            const helpText = `‚ï≠‚îÄ‚åà üéµ *ANTI-AUDIO* ‚åã\n‚îÇ\n‚îú‚îÄ‚ä∑ *.antiaudio on <warn|delete|kick>*\n‚îÇ  ‚îî‚ä∑ Enable with mode\n‚îú‚îÄ‚ä∑ *.antiaudio off*\n‚îÇ  ‚îî‚ä∑ Disable protection\n‚îú‚îÄ‚ä∑ *.antiaudio types [add/remove/list]*\n‚îÇ  ‚îî‚ä∑ Manage audio types\n‚îú‚îÄ‚ä∑ *.antiaudio exemptadmins [on/off]*\n‚îÇ  ‚îî‚ä∑ Toggle admin exemption\n‚îú‚îÄ‚ä∑ *.antiaudio status*\n‚îÇ  ‚îî‚ä∑ View current status\n‚ï∞‚îÄ‚îÄ‚îÄ`;
            
            await sock.sendMessage(chatId, { text: helpText }, { quoted: msg });
        }
    }
};

function setupAntiAudioListener(sock) {
    console.log('üîß Setting up anti-audio listener for audio messages...');
    
    sock.ev.on('messages.upsert', async ({ messages }) => {
        const newMsg = messages[0];
        
        // Skip if no message or not a group message
        if (!newMsg || !newMsg.key.remoteJid?.endsWith('@g.us')) return;
        
        // Skip bot's own messages
        if (newMsg.key.fromMe) return;
        
        const chatId = newMsg.key.remoteJid;
        
        // Load current settings
        const settings = loadAntiAudio();
        const groupSettings = settings.find(g => g.chatId === chatId);
        
        // Skip if anti-audio not enabled for this group
        if (!groupSettings || !groupSettings.enabled) return;
        
        // Check if message contains blocked audio type
        const message = newMsg.message;
        let audioType = null;
        let isAudio = false;
        
        // DEBUG: Log the message structure to see what's available
        console.log('DEBUG: Checking message type:', Object.keys(message || {}));
        
        // Check for audio messages - FIXED DETECTION
        if (message?.audioMessage || message?.pttMessage) {
            console.log('DEBUG: Audio message detected!');
            
            // For WhatsApp Web, audio might be in audioMessage or pttMessage
            const audioMsg = message.audioMessage || message.pttMessage;
            
            if (audioMsg) {
                console.log('DEBUG: Audio properties:', {
                    ptt: audioMsg.ptt,
                    mimetype: audioMsg.mimetype,
                    seconds: audioMsg.seconds,
                    fileName: audioMsg.fileName
                });
                
                // Determine audio type based on properties
                if (audioMsg.ptt === true) {
                    audioType = 'voice'; // Voice note (push-to-talk)
                } else if (audioMsg.mimetype?.includes('audio/')) {
                    // Check if it's music based on file name or duration
                    const isMusic = audioMsg.fileName?.match(/\.(mp3|m4a|flac|wav|ogg)$/i) ||
                                   audioMsg.seconds > 60; // Long audio might be music
                    audioType = isMusic ? 'music' : 'audio';
                } else {
                    audioType = 'audio'; // Generic audio
                }
                
                isAudio = true;
                console.log(`DEBUG: Detected audio type: ${audioType}`);
            }
        }
        
        // Skip if not audio or audio type not blocked
        if (!isAudio || !audioType || !groupSettings.audioTypes?.includes(audioType)) {
            console.log(`DEBUG: Skipping - isAudio: ${isAudio}, audioType: ${audioType}, in blocked types: ${groupSettings.audioTypes?.includes(audioType)}`);
            return;
        }
        
        // Get sender
        const messageSender = newMsg.key.participant || newMsg.key.remoteJid;
        const cleanMessageSender = cleanJid(messageSender);
        const senderNumber = cleanMessageSender.split('@')[0];
        
        try {
            // Fetch group metadata
            const groupMetadata = await sock.groupMetadata(chatId);
            
            // Check if sender is admin
            let isSenderAdmin = false;
            const senderParticipant = groupMetadata.participants.find(p => {
                const cleanParticipantJid = cleanJid(p.id);
                return cleanParticipantJid === cleanMessageSender;
            });
            
            isSenderAdmin = senderParticipant?.admin === 'admin' || senderParticipant?.admin === 'superadmin';
            
            // Skip if sender is admin and exemptAdmins is true
            if (isSenderAdmin && groupSettings.exemptAdmins) {
                console.log(`Skipping admin ${cleanMessageSender} for ${audioType} in ${chatId}`);
                return;
            }
            
            console.log(`${audioType.toUpperCase()} detected from ${cleanMessageSender} in ${chatId}`);
            
            // Initialize warning count for user if not exists
            if (!groupSettings.warningCount) {
                groupSettings.warningCount = {};
            }
            
            const userId = cleanMessageSender;
            if (!groupSettings.warningCount[userId]) {
                groupSettings.warningCount[userId] = 0;
            }
            
            // Audio type names for display
            const audioTypeNames = {
                'audio': 'Audio message',
                'voice': 'Voice note',
                'music': 'Music file'
            };
            
            const audioName = audioTypeNames[audioType] || audioType;
            
            // Handle based on mode
            switch (groupSettings.mode) {
                case 'warn':
                    groupSettings.warningCount[userId]++;
                    const warnings = groupSettings.warningCount[userId];
                    
                    await sock.sendMessage(chatId, { 
                        text: `‚ö†Ô∏è *Audio Warning* @${senderNumber}\n\n${audioName}s are not allowed in this group!\nWarning #${warnings}\n\nRepeated violations may result in stricter actions.`,
                        mentions: [cleanMessageSender]
                    });
                    
                    // Update settings with warning count
                    const warnSettingsIndex = settings.findIndex(g => g.chatId === chatId);
                    if (warnSettingsIndex !== -1) {
                        settings[warnSettingsIndex] = groupSettings;
                        saveAntiAudio(settings);
                    }
                    break;
                    
                case 'delete':
                    // Send warning
                    await sock.sendMessage(chatId, { 
                        text: `üö´ *Audio Deleted* @${senderNumber}\n\n${audioName}s are not allowed in this group!\nYour ${audioType} has been removed.`,
                        mentions: [cleanMessageSender]
                    });
                    
                    // Try to delete the message
                    try {
                        await sock.sendMessage(chatId, { 
                            delete: {
                                id: newMsg.key.id,
                                participant: messageSender,
                                remoteJid: chatId,
                                fromMe: false
                            }
                        });
                        console.log(`Deleted ${audioType} from ${cleanMessageSender} in ${chatId}`);
                    } catch (deleteError) {
                        console.error('Failed to delete audio:', deleteError);
                    }
                    break;
                    
                case 'kick':
                    // Check if bot is superadmin
                    const botJid = cleanJid(sock.user?.id);
                    const botParticipant = groupMetadata.participants.find(p => {
                        const cleanParticipantJid = cleanJid(p.id);
                        return cleanParticipantJid === botJid;
                    });
                    const botIsSuperAdmin = botParticipant?.admin === 'superadmin';
                    
                    if (!botIsSuperAdmin) {
                        await sock.sendMessage(chatId, { 
                            text: `‚ö†Ô∏è *Cannot Kick*\n\nI need superadmin permissions to kick members.\n\nUser @${senderNumber} shared a ${audioType} but I cannot kick them.`,
                            mentions: [cleanMessageSender]
                        });
                        return;
                    }
                    
                    // Send warning before kick
                    await sock.sendMessage(chatId, { 
                        text: `üö´ *Violation Detected* @${senderNumber}\n\nSharing ${audioName}s is not allowed in this group!\nYou will be kicked for this violation.`,
                        mentions: [cleanMessageSender]
                    });
                    
                    // Wait a moment then kick
                    setTimeout(async () => {
                        try {
                            await sock.groupParticipantsUpdate(chatId, [cleanMessageSender], 'remove');
                            await sock.sendMessage(chatId, { 
                                text: `üë¢ *User Kicked*\n\n@${senderNumber} was removed for sharing a ${audioName}.`
                            });
                        } catch (kickError) {
                            console.error('Failed to kick user:', kickError);
                            await sock.sendMessage(chatId, { 
                                text: `‚ùå *Failed to kick user*\n\nCould not remove @${senderNumber}. Please check my permissions.`,
                                mentions: [cleanMessageSender]
                            });
                        }
                    }, 2000);
                    break;
            }
            
        } catch (error) {
            console.error('Error handling audio detection:', error);
        }
    });
    
    console.log('‚úÖ Anti-audio listener attached for audio messages');
}