






































//INNER-PEACE - SILENT WOLF






















// ====== SILENT WOLFBOT - ULTIMATE CLEAN EDITION (SPEED OPTIMIZED) ======
// Features: Real-time prefix changes, UltimateFix, Status Detection, Auto-Connect
// SUPER CLEAN TERMINAL - Zero spam, Zero session noise, Rate limit protection
// Date: 2024 | Version: 1.1.5 (PREFIXLESS & NEW MEMBER DETECTION)
// New: Session ID authentication from process.env.SESSION_ID
// New: WOLF-BOT session format support (WOLF-BOT:eyJ...)
// New: Professional success messaging like WOLFBOT
// New: Prefixless mode support
// New: Group new member detection with terminal notifications
// New: Anti-ViewOnce system integrated (Private/Auto modes)

// ====== PERFORMANCE OPTIMIZATIONS APPLIED ======
// 1. Reduced mandatory delays from 1000ms to 100ms
// 2. Optimized console filtering overhead
// 3. Parallel processing for non-critical tasks
// 4. Faster command parsing
// 5. All original features preserved 100%

// ====== ULTIMATE CONSOLE INTERCEPTOR (OPTIMIZED) ======
//Silent Wolf

const originalConsoleMethods = {
    log: console.log,
    info: console.info,
    warn: console.warn,
    error: console.error,
    debug: console.debug,
    trace: console.trace,
    dir: console.dir,
    dirxml: console.dirxml,
    table: console.table,
};
globalThis.originalConsoleMethods = originalConsoleMethods;
const _keepRef = {
    time: console.time,
    timeEnd: console.timeEnd,
    timeLog: console.timeLog,
    group: console.group,
    groupEnd: console.groupEnd,
    groupCollapsed: console.groupCollapsed,
    clear: console.clear,
    count: console.count,
    countReset: console.countReset,
    assert: console.assert,
    profile: console.profile,
    profileEnd: console.profileEnd,
    timeStamp: console.timeStamp,
    context: console.context
};

const _noisyTokens = [
    'closing session','sessionentry','registrationid','currentratchet',
    'indexinfo','pendingprekey','ephemeralkeypair','lastremoteephemeralkey',
    'rootkey','basekey','signalkey','signalprotocol','_chains','chains',
    'chainkey','ratchet','cipher','decrypt','encrypt','prekey','signedkey',
    'identitykey','sessionstate','keystore','senderkey','groupcipher',
    'signalgroup','signalstore','signalrepository','signalprotocolstore',
    'sessioncipher','sessionbuilder','senderkeystore','senderkeydistribution',
    'keyexchange','buffer','<buffer','byte','05 ','0x','pubkey','privkey',
    'baileys','whatsapp','qr','scan','pairing','connection.update',
    'creds.update','messages.upsert','presence.update','chat.update',
    'message.receipt.update','message.update','timeout','transaction',
    'failed to decrypt','received error','sessionerror','bad mac',
    'stream errored','autoreact','autoview','autoreactstatus','autoviewstatus',
    '[asm-debug]'
];

const _importantTokens = [
    'command','‚îå','‚îÇ','‚îî','‚ïî','‚ïë','‚ïö',
    '‚úÖ','‚ùå','üë•','üë§','üìä','üîß','üê∫','üöÄ','‚ö†Ô∏è',
    'üì±','üóëÔ∏è','üì§','üëë','üéØ','üõ°Ô∏è','üéµ','üé¨','üìò',
    'üì∑','üíæ','üîí','üîç','üí¨'
];
const shouldShowLog = (args) => {
    if (args.length === 0) return true;
    const firstArg = args[0];
    if (typeof firstArg !== 'string') return true;
    const lowerMsg = firstArg.toLowerCase();
    for (let i = 0; i < _importantTokens.length; i++) {
        if (lowerMsg.includes(_importantTokens[i])) return true;
    }
    for (let i = 0; i < _noisyTokens.length; i++) {
        if (lowerMsg.includes(_noisyTokens[i])) return false;
    }
    return true;
};

for (const method of Object.keys(originalConsoleMethods)) {
    if (typeof console[method] === 'function') {
        console[method] = function(...args) {
            if (shouldShowLog(args)) {
                originalConsoleMethods[method].apply(console, args);
            }
        };
    }
}

// Process-level filtering
function setupProcessFilter() {
    const originalStdoutWrite = process.stdout.write;
    const originalStderrWrite = process.stderr.write;
    
    const _stdoutNoisy = [
        'closing session','sessionentry','registrationid','currentratchet',
        'indexinfo','pendingprekey','_chains','ephemeralkeypair',
        'lastremoteephemeralkey','rootkey','basekey','signalprotocol',
        'ratchet','chainkey','senderkey','groupcipher','sessioncipher',
        'sessionbuilder'
    ];
    
    const filterOutput = (chunk) => {
        if (typeof chunk !== 'string' && !Buffer.isBuffer(chunk)) return true;
        const lowerChunk = (typeof chunk === 'string' ? chunk : chunk.toString()).toLowerCase();
        if (lowerChunk.length < 5) return true;
        for (let i = 0; i < _stdoutNoisy.length; i++) {
            if (lowerChunk.includes(_stdoutNoisy[i])) return false;
        }
        return true;
    };
    
    process.stdout.write = function(chunk, encoding, callback) {
        if (filterOutput(chunk)) {
            return originalStdoutWrite.call(this, chunk, encoding, callback);
        }
        if (callback) callback();
        return true;
    };
    
    process.stderr.write = function(chunk, encoding, callback) {
        if (filterOutput(chunk)) {
            return originalStderrWrite.call(this, chunk, encoding, callback);
        }
        if (callback) callback();
        return true;
    };
}

// Set environment variables
process.env.DEBUG = '';
process.env.NODE_ENV = 'production';
process.env.BAILEYS_LOG_LEVEL = 'fatal';
process.env.PINO_LOG_LEVEL = 'fatal';
process.env.BAILEYS_DISABLE_LOG = 'true';
process.env.DISABLE_BAILEYS_LOG = 'true';
process.env.PINO_DISABLE = 'true';

// Import modules
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import fs from 'fs';
import path from 'path';
import dotenv from 'dotenv';
import chalk from 'chalk';
import readline from 'readline';
import { exec, execSync } from 'child_process';
import axios from "axios";
import { normalizeMessageContent, downloadContentFromMessage, downloadMediaMessage, jidNormalizedUser } from '@whiskeysockets/baileys';
import NodeCache from 'node-cache';
import { isSudoNumber, isSudoJid, getSudoMode, addSudoJid, mapLidToPhone, isSudoByLid, getPhoneFromLid, getSudoList } from './lib/sudo-store.js';
import supabaseDb, { setConfigBotId } from './lib/supabase.js';
import { migrateSudoToSupabase, initSudo, setBotId } from './lib/sudo-store.js';
import { migrateWarningsToSupabase } from './lib/warnings-store.js';

const msgRetryCounterCache = new NodeCache({ stdTTL: 600 });

let currentSock = null;

const lidPhoneCache = new Map();
const phoneLidCache = new Map();

function cacheLidPhone(lidNum, phoneNum) {
    if (!lidNum || !phoneNum || lidNum === phoneNum) return;
    lidPhoneCache.set(lidNum, phoneNum);
    phoneLidCache.set(phoneNum, lidNum);
    mapLidToPhone(lidNum, phoneNum);
}

function resolvePhoneFromLid(jid) {
    if (!jid) return null;
    const lidNum = jid.split('@')[0].split(':')[0];

    const cached = lidPhoneCache.get(lidNum);
    if (cached) return cached;
    const stored = getPhoneFromLid(lidNum);
    if (stored) {
        lidPhoneCache.set(lidNum, stored);
        return stored;
    }

    if (!currentSock) return null;
    try {
        if (currentSock.signalRepository?.lidMapping?.getPNForLID) {
            const pn = currentSock.signalRepository.lidMapping.getPNForLID(jid);
            if (pn) {
                const num = String(pn).split('@')[0].replace(/[^0-9]/g, '');
                if (num.length >= 7 && num !== lidNum) {
                    cacheLidPhone(lidNum, num);
                    return num;
                }
            }
        }
    } catch {}

    try {
        const fullLid = jid.includes('@') ? jid : `${jid}@lid`;
        if (currentSock.signalRepository?.lidMapping?.getPNForLID) {
            const formats = [fullLid, `${lidNum}:0@lid`, `${lidNum}@lid`];
            for (const fmt of formats) {
                try {
                    const pn = currentSock.signalRepository.lidMapping.getPNForLID(fmt);
                    if (pn) {
                        const num = String(pn).split('@')[0].replace(/[^0-9]/g, '');
                        if (num.length >= 7 && num.length <= 15 && num !== lidNum) {
                            cacheLidPhone(lidNum, num);
                            return num;
                        }
                    }
                } catch {}
            }
        }
    } catch {}

    return null;
}

async function resolvePhoneFromGroup(senderJid, chatId, sock) {
    return resolveSenderFromGroup(senderJid, chatId, sock);
}

function getDisplayNumber(senderJid) {
    if (!senderJid) return 'unknown';
    const raw = senderJid.split('@')[0].split(':')[0];
    const full = senderJid.split('@')[0];
    if (senderJid.includes('@lid')) {
        const phone = lidPhoneCache.get(raw) || lidPhoneCache.get(full) || getPhoneFromLid(raw) || getPhoneFromLid(full);
        return phone ? `+${phone}` : `LID:${raw.substring(0, 8)}...`;
    }
    return `+${raw}`;
}

const groupMetadataCache = new Map();
globalThis.groupMetadataCache = groupMetadataCache;
const GROUP_CACHE_TTL = 10 * 60 * 1000;
const groupDiagDone = new Set();
const _pendingGroupFetches = new Map();

async function getCachedGroupMetadata(chatId, sock) {
    const cached = groupMetadataCache.get(chatId);
    if (cached && Date.now() - cached.ts < GROUP_CACHE_TTL) {
        return cached.data;
    }
    const pending = _pendingGroupFetches.get(chatId);
    if (pending) return pending;
    const fetchPromise = (async () => {
        try {
            const metadata = await Promise.race([
                sock.groupMetadata(chatId),
                new Promise((_, rej) => setTimeout(() => rej(new Error('timeout')), 8000))
            ]);
            groupMetadataCache.set(chatId, { data: metadata, ts: Date.now() });
            return metadata;
        } catch (err) {
            if (cached) return cached.data;
            return null;
        } finally {
            _pendingGroupFetches.delete(chatId);
        }
    })();
    _pendingGroupFetches.set(chatId, fetchPromise);
    return fetchPromise;
}

async function resolveDisplayNumber(jid, chatId, sock) {
    if (!jid) return 'unknown';
    const raw = jid.split('@')[0].split(':')[0];
    const full = jid.split('@')[0];
    
    if (!jid.includes('@lid')) return `+${raw}`;
    
    const cached = lidPhoneCache.get(raw) || lidPhoneCache.get(full) || getPhoneFromLid(raw) || getPhoneFromLid(full);
    if (cached) return `+${cached}`;
    
    const fromSignal = resolvePhoneFromLid(jid);
    if (fromSignal) return `+${fromSignal}`;
    
    if (chatId?.includes('@g.us') && sock) {
        try {
            const resolved = await resolveSenderFromGroup(jid, chatId, sock);
            if (resolved) return `+${resolved}`;
        } catch {}
    }
    
    return `LID:${raw.substring(0, 8)}...`;
}

async function generateRetrievalCaption(senderJid, retrieverJid, chatId, groupName, sock) {
    const isGroup = chatId?.includes('@g.us');
    
    let resolvedGroupName = groupName;
    if (isGroup && !resolvedGroupName && sock) {
        try {
            const metadata = await getCachedGroupMetadata(chatId, sock);
            if (metadata?.subject) resolvedGroupName = metadata.subject;
        } catch {}
    }
    
    const senderNumber = await resolveDisplayNumber(senderJid, chatId, sock);
    const isAutoDetect = retrieverJid === 'auto-detect';
    const retrieverDisplay = isAutoDetect ? 'WOLFBOT (Auto)' : await resolveDisplayNumber(retrieverJid, chatId, sock);
    const chatName = resolvedGroupName || (isGroup ? chatId.split('@')[0] : 'Private Chat');
    const timeStr = new Date().toLocaleString('en-US', {
        year: 'numeric', month: 'short', day: 'numeric',
        hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true
    });

    let caption = `‚ï≠‚åà üîê *VIEW-ONCE RETRIEVED* ‚åã\n`;
    caption += `‚îú‚ä∑ üì§ *Sent by:* ${senderNumber}\n`;
    caption += `‚îú‚ä∑ üì• *Retrieved by:* ${retrieverDisplay}\n`;
    caption += `‚îú‚ä∑ üïê *Time:* ${timeStr}\n`;
    caption += `‚ï∞‚ä∑ üí¨ *${isGroup ? 'Group' : 'Chat'}:* ${chatName}\n`;
    caption += `> Retrieved by WOLFBOT`;
    return caption;
}

async function buildLidMapFromGroup(chatId, sock) {
    const metadata = await getCachedGroupMetadata(chatId, sock);
    if (!metadata) return 0;
    const participants = metadata.participants || [];
    let mapped = 0;

    if (!groupDiagDone.has(chatId) && participants.length > 0) {
        groupDiagDone.add(chatId);
        const sample = participants.slice(0, 3).map(p => ({
            id: p.id || 'none',
            lid: p.lid || 'none',
            phoneNumber: p.phoneNumber || 'none',
            admin: p.admin || 'none',
            keys: Object.keys(p).filter(k => !['id','lid','admin','phoneNumber'].includes(k)).join(',')
        }));
        UltraCleanLogger.info(`üìã Group participant structure (${metadata.subject || chatId.split('@')[0].substring(0, 10)}): ${JSON.stringify(sample)}`);
    }
    
    for (const p of participants) {
        const { phoneNum, lidNum } = extractParticipantInfo(p, sock);

        if (phoneNum && lidNum && phoneNum !== lidNum) {
            cacheLidPhone(lidNum, phoneNum);
            mapLidToPhone(lidNum, phoneNum);
            mapped++;
        }
    }
    return mapped;
}

const _lidResolveAttempts = new Map();
const LID_RESOLVE_COOLDOWN = 5 * 60 * 1000;
let _activeGroupFetches = 0;
const MAX_CONCURRENT_GROUP_FETCHES = 2;

async function resolveSenderFromGroup(senderJid, chatId, sock) {
    if (!senderJid || !chatId || !sock) return null;
    const senderLidNum = senderJid.split('@')[0].split(':')[0];
    const senderFull = senderJid.split('@')[0];

    let resolved = lidPhoneCache.get(senderLidNum) || lidPhoneCache.get(senderFull) || getPhoneFromLid(senderLidNum) || getPhoneFromLid(senderFull);
    if (resolved) return resolved;

    const attemptKey = `${senderLidNum}:${chatId}`;
    const lastAttempt = _lidResolveAttempts.get(attemptKey);
    if (lastAttempt && Date.now() - lastAttempt < LID_RESOLVE_COOLDOWN) return null;
    _lidResolveAttempts.set(attemptKey, Date.now());

    if (_lidResolveAttempts.size > 500) {
        const cutoff = Date.now() - LID_RESOLVE_COOLDOWN;
        for (const [k, ts] of _lidResolveAttempts) {
            if (ts < cutoff) _lidResolveAttempts.delete(k);
        }
    }

    if (_activeGroupFetches >= MAX_CONCURRENT_GROUP_FETCHES) return null;
    _activeGroupFetches++;
    try {
        await buildLidMapFromGroup(chatId, sock);
    } finally {
        _activeGroupFetches--;
    }

    resolved = lidPhoneCache.get(senderLidNum) || lidPhoneCache.get(senderFull) || getPhoneFromLid(senderLidNum) || getPhoneFromLid(senderFull);
    if (resolved) {
        UltraCleanLogger.info(`üîó LID resolved: ${senderLidNum.substring(0, 8)}... ‚Üí +${resolved}`);
    }
    return resolved;
}

function extractParticipantInfo(p, sock) {
    const pid = p.id || '';
    const plid = p.lid || '';
    let phoneNum = null;
    let lidNum = null;

    if (p.phoneNumber) {
        const num = String(p.phoneNumber).replace(/[^0-9]/g, '');
        if (num.length >= 7 && num.length <= 15) phoneNum = num;
    }

    if (!phoneNum && pid && !pid.includes('@lid')) {
        const num = pid.split('@')[0].split(':')[0].replace(/[^0-9]/g, '');
        if (num.length >= 7 && num.length <= 15) phoneNum = num;
    }

    if (!phoneNum && plid && !plid.includes('@lid')) {
        const num = plid.split('@')[0].split(':')[0].replace(/[^0-9]/g, '');
        if (num.length >= 7 && num.length <= 15) phoneNum = num;
    }

    if (pid.includes('@lid')) {
        lidNum = pid.split('@')[0].split(':')[0];
    }
    if (!lidNum && plid && plid.includes('@lid')) {
        lidNum = plid.split('@')[0].split(':')[0];
    }
    if (!lidNum && plid) {
        lidNum = plid.split('@')[0].split(':')[0];
    }

    if (!phoneNum && lidNum) {
        try {
            const theLid = pid.includes('@lid') ? pid : (plid || pid);
            if (sock?.signalRepository?.lidMapping?.getPNForLID) {
                const pn = sock.signalRepository.lidMapping.getPNForLID(theLid);
                if (pn) {
                    const num = String(pn).split('@')[0].replace(/[^0-9]/g, '');
                    if (num.length >= 7 && num.length <= 15) phoneNum = num;
                }
            }
        } catch {}
    }

    return { phoneNum, lidNum };
}

async function autoScanGroupsForSudo(sock) {
    try {
        const { sudoers } = getSudoList();
        if (sudoers.length === 0) return;

        const allSudosMapped = sudoers.every(num => {
            for (const [, phone] of lidPhoneCache) {
                if (phone === num) return true;
            }
            const stored = getPhoneFromLid(num);
            if (stored) return true;
            return false;
        });
        if (allSudosMapped) {
            UltraCleanLogger.info(`üîë All ${sudoers.length} sudo(s) already have LID mappings`);
            return;
        }

        UltraCleanLogger.info(`üîë Scanning groups to link ${sudoers.length} sudo user(s)...`);
        const groups = await Promise.race([
            sock.groupFetchAllParticipating(),
            new Promise((_, rej) => setTimeout(() => rej(new Error('scan_timeout')), 15000))
        ]);
        if (!groups) return;
        let linked = 0;
        let totalParticipants = 0;
        let diagLogged = false;

        const groupEntries = Object.entries(groups);
        for (let gi = 0; gi < groupEntries.length; gi++) {
            const [groupId, metadata] = groupEntries[gi];
            const participants = metadata.participants || [];
            totalParticipants += participants.length;

            if (!diagLogged && participants.length > 0) {
                diagLogged = true;
                const sample = participants.slice(0, 2).map(p => ({
                    id: p.id || 'none', lid: p.lid || 'none',
                    phoneNumber: p.phoneNumber || 'none',
                    keys: Object.keys(p).filter(k => !['id','lid','admin','phoneNumber'].includes(k)).join(',')
                }));
                UltraCleanLogger.info(`üìã Scan participant structure: ${JSON.stringify(sample)}`);
            }

            for (const p of participants) {
                const { phoneNum, lidNum } = extractParticipantInfo(p, sock);

                if (phoneNum && lidNum && phoneNum !== lidNum) {
                    cacheLidPhone(lidNum, phoneNum);
                    mapLidToPhone(lidNum, phoneNum);
                    if (sudoers.includes(phoneNum)) linked++;
                }

                const pid = p.id || '';
                const plid = p.lid || '';
                if (pid && !pid.includes('@lid')) {
                    const phoneN = pid.split('@')[0].split(':')[0].replace(/[^0-9]/g, '');
                    if (phoneN && sudoers.includes(phoneN)) {
                        const lidJid = plid || pid;
                        if (lidJid.includes('@lid')) {
                            const lNum = lidJid.split('@')[0].split(':')[0];
                            cacheLidPhone(lNum, phoneN);
                            linked++;
                        }
                    }
                }
            }
            if (gi % 10 === 9) await new Promise(r => setTimeout(r, 0));
        }

        UltraCleanLogger.info(`üîë Scanned ${Object.keys(groups).length} groups, ${totalParticipants} participants`);
        if (linked > 0) {
            UltraCleanLogger.success(`üîë Auto-linked ${linked} sudo user(s) from group scan`);
        } else {
            UltraCleanLogger.info(`üîë No sudo users found via group scan. Use =linksudo in a group with your sudo user.`);
        }
    } catch (err) {
        UltraCleanLogger.warning(`Sudo auto-scan: ${err.message}`);
    }
}

// Import automation handlers
import { handleAutoReact } from './commands/automation/autoreactstatus.js';
import { handleChannelReact } from './commands/channel/channelreact.js';
import { handleReactOwner } from './commands/automation/reactowner.js';
import { handleReactDev } from './commands/automation/reactdev.js';
import { handleAutoView } from './commands/automation/autoviewstatus.js';
import { initializeAutoJoin } from './commands/group/add.js';
import antidemote from './commands/group/antidemote.js';
import banCommand from './commands/group/ban.js';

// Pre-imported group event modules (avoids dynamic import disk I/O in hot event handlers)
import { handleGroupParticipantUpdate as antidemoteHandler } from './commands/group/antidemote.js';
import { isWelcomeEnabled, getWelcomeMessage, sendWelcomeMessage } from './commands/group/welcome.js';
import { isGoodbyeEnabled, getGoodbyeMessage, sendGoodbyeMessage } from './commands/group/goodbye.js';
import { handleStatusMention as statusMentionHandler } from './commands/group/antistatusmention.js';

// Import antidelete system (listeners registered in index.js, always active)
import { initAntidelete, antideleteStoreMessage, antideleteHandleUpdate, updateAntideleteSock } from './commands/owner/antidelete.js';

// Import status antidelete system (always on, handles status messages exclusively)
import { initStatusAntidelete, statusAntideleteStoreMessage, statusAntideleteHandleUpdate, updateStatusAntideleteSock } from './commands/owner/antideletestatus.js';

// Import W.O.L.F chatbot system
import { isChatbotActiveForChat, handleChatbotMessage } from './commands/ai/chatbot.js';

// ====== ENVIRONMENT SETUP ======
dotenv.config({ path: './.env' });

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);


// ====== CONFIGURATION ======
const SESSION_DIR = './session';
const BOT_NAME = process.env.BOT_NAME || 'WOLFBOT';
const VERSION = '1.1.5';
global.VERSION = VERSION;
const DEFAULT_PREFIX = process.env.PREFIX || '.';
const OWNER_FILE = './owner.json';
const PREFIX_CONFIG_FILE = './prefix_config.json';
const BOT_SETTINGS_FILE = './bot_settings.json';
const BOT_MODE_FILE = './bot_mode.json';
const WHITELIST_FILE = './whitelist.json';
const BLOCKED_USERS_FILE = './blocked_users.json';
const WELCOME_DATA_FILE = './data/welcome_data.json';

let _cache_owner_data = null;
let _cache_prefix_config = null;
let _cache_bot_settings = null;
let _cache_bot_mode = null;
let _cache_whitelist = null;
let _cache_blocked_users = null;
let _cache_welcome_data = null;
let _cache_status_logs = null;
let _cache_member_detection = null;
let _cache_antiviewonce_config = null;
let _cache_antiviewonce_history = null;
let _cache_antiviewonce_captured_count = 0;

async function _loadConfigCache(key, defaultValue) {
    try {
        const val = await supabaseDb.getConfig(key, defaultValue);
        return val;
    } catch {
        return defaultValue;
    }
}

function _saveConfigCache(key, value) {
    supabaseDb.setConfig(key, value).catch(err => {
        UltraCleanLogger.warning(`DB save error for ${key}: ${err.message}`);
    });
}

async function reloadConfigCaches() {
    try {
        _cache_owner_data = await _loadConfigCache('owner_data', {});
        _cache_prefix_config = await _loadConfigCache('prefix_config', { prefix: '.' });
        _cache_bot_settings = await _loadConfigCache('bot_settings', {});
        _cache_bot_mode = await _loadConfigCache('bot_mode', { mode: 'public' });
        _cache_whitelist = await _loadConfigCache('whitelist', { whitelist: [] });
        _cache_blocked_users = await _loadConfigCache('blocked_users', { blocked: [] });
        _cache_welcome_data = await _loadConfigCache('welcome_data', {});
        _cache_status_logs = await _loadConfigCache('status_detection_logs', {});
        _cache_member_detection = await _loadConfigCache('member_detection', {});
        _cache_antiviewonce_config = await _loadConfigCache('antiviewonce_config', DEFAULT_ANTIVIEWONCE_CONFIG);
        _cache_antiviewonce_history = await _loadConfigCache('antiviewonce_history', {});
        if (_cache_owner_data && Object.keys(_cache_owner_data).length === 0) _cache_owner_data = null;
        if (_cache_bot_settings && Object.keys(_cache_bot_settings).length === 0) _cache_bot_settings = null;
        if (_cache_welcome_data && Object.keys(_cache_welcome_data).length === 0) _cache_welcome_data = null;
    } catch {}
}

// Auto-connect features
const AUTO_CONNECT_ON_LINK = true;
const AUTO_CONNECT_ON_START = true;

// SPEED OPTIMIZATION
const RATE_LIMIT_ENABLED = true;
const MIN_COMMAND_DELAY = 100;
const STICKER_DELAY = 400;

// // Auto-join group configuration
// const AUTO_JOIN_ENABLED = true;
// const AUTO_JOIN_DELAY = 5000;
// const SEND_WELCOME_MESSAGE = true;
// const GROUP_LINK = 'https://chat.whatsapp.com/G3RopQF1UcSD7AeoVsd6PG';
// const GROUP_INVITE_CODE = GROUP_LINK.split('/').pop();
// const GROUP_NAME = 'WolfBot Community';
// const AUTO_JOIN_LOG_FILE = './auto_join_log.json';

// ====== SILENCE BAILEYS ======
function silenceBaileysCompletely() {
    try {
        const pino = require('pino');
        pino({ level: 'silent', enabled: false });
    } catch {}
}
silenceBaileysCompletely();

// ====== CLEAN CONSOLE SETUP ======
console.clear();
setupProcessFilter();

// Ultra clean logger
const _logSuppressSet = new Set([
    'closing session','sessionentry','_chains','registrationid','currentratchet',
    'indexinfo','pendingprekey','ephemeralkeypair','lastremoteephemeralkey',
    'rootkey','basekey','signalprotocol','signalkey','signalgroup','signalstore',
    'signalrepository','sessioncipher','sessionbuilder','sessionstate',
    'senderkeystore','senderkeydistribution','keyexchange','groupcipher',
    'ratchet','chainkey','keypair','pubkey','privkey','keystore',
    '<buffer','05 ','0x','failed to decrypt','bad mac','stream errored',
    'sessionerror','received error','connection.update','creds.update',
    'messages.upsert','presence.update','chat.update','message.receipt.update',
    'message.update','[asm-debug]','autoreact','autoview'
]);
const _logSuppressArr = [..._logSuppressSet];
const _errSuppressArr = [
    'bad mac','failed to decrypt','decrypt','session error','sessioncipher',
    'sessionbuilder','session_cipher','signalprotocol','ratchet','closed session',
    'stream errored','verifymac','libsignal','hmac','pre-key','prekey'
];
const _warnSuppressArr = [
    'decrypted message with closed session','failed to decrypt','bad mac',
    'closing session','stream errored','signalprotocol','ratchet',
    'sessioncipher','sessionbuilder','sessionentry','sessionstate','sessionerror'
];
function _isLogSuppressed(msg) {
    for (let i = 0; i < _logSuppressArr.length; i++) {
        if (msg.includes(_logSuppressArr[i])) return true;
    }
    return false;
}

class UltraCleanLogger {
    static log(...args) {
        const firstArg = args[0];
        if (typeof firstArg === 'string') {
            const lower = firstArg.toLowerCase();
            if (_isLogSuppressed(lower)) return;
        }
        const timestamp = chalk.gray(`[${new Date().toLocaleTimeString()}]`);
        originalConsoleMethods.log(timestamp, ...args);
    }
    
    static error(...args) {
        const message = args.join(' ').toLowerCase();
        for (let i = 0; i < _errSuppressArr.length; i++) {
            if (message.includes(_errSuppressArr[i])) return;
        }
        const timestamp = chalk.red(`[${new Date().toLocaleTimeString()}]`);
        originalConsoleMethods.error(timestamp, ...args);
    }
    
    static success(...args) {
        const timestamp = chalk.green(`[${new Date().toLocaleTimeString()}]`);
        originalConsoleMethods.log(timestamp, chalk.green('‚úÖ'), ...args);
    }
    
    static info(...args) {
        const timestamp = chalk.blue(`[${new Date().toLocaleTimeString()}]`);
        originalConsoleMethods.log(timestamp, chalk.blue('‚ÑπÔ∏è'), ...args);
    }
    
    static warning(...args) {
        const message = args.join(' ').toLowerCase();
        for (let i = 0; i < _warnSuppressArr.length; i++) {
            if (message.includes(_warnSuppressArr[i])) return;
        }
        const timestamp = chalk.yellow(`[${new Date().toLocaleTimeString()}]`);
        originalConsoleMethods.log(timestamp, chalk.yellow('‚ö†Ô∏è'), ...args);
    }
    
    static event(...args) {
        const timestamp = chalk.magenta(`[${new Date().toLocaleTimeString()}]`);
        originalConsoleMethods.log(timestamp, chalk.magenta('üé≠'), ...args);
    }
    
    static command(...args) {
        const timestamp = chalk.cyan(`[${new Date().toLocaleTimeString()}]`);
        originalConsoleMethods.log(timestamp, chalk.cyan('üí¨'), ...args);
    }
    
    static critical(...args) {
        const timestamp = chalk.red(`[${new Date().toLocaleTimeString()}]`);
        originalConsoleMethods.error(timestamp, chalk.red('üö®'), ...args);
    }
    
    static group(...args) {
        const timestamp = chalk.magenta(`[${new Date().toLocaleTimeString()}]`);
        originalConsoleMethods.log(timestamp, chalk.magenta('üë•'), ...args);
    }
    
    static member(...args) {
        const timestamp = chalk.cyan(`[${new Date().toLocaleTimeString()}]`);
        originalConsoleMethods.log(timestamp, chalk.cyan('üë§'), ...args);
    }
    
    static antiviewonce(...args) {
        const timestamp = chalk.magenta(`[${new Date().toLocaleTimeString()}]`);
        originalConsoleMethods.log(timestamp, chalk.magenta('üîê'), ...args);
    }
}

// Replace console methods
console.log = UltraCleanLogger.log;
console.error = UltraCleanLogger.error;
console.info = UltraCleanLogger.info;
console.warn = UltraCleanLogger.warning;
console.debug = () => {};

// Add custom methods
global.logSuccess = UltraCleanLogger.success;
global.logInfo = UltraCleanLogger.info;
global.logWarning = UltraCleanLogger.warning;
global.logEvent = UltraCleanLogger.event;
global.logCommand = UltraCleanLogger.command;
global.logGroup = UltraCleanLogger.group;
global.logMember = UltraCleanLogger.member;
global.logAntiViewOnce = UltraCleanLogger.antiviewonce;

// Ultra silent baileys logger
const ultraSilentLogger = {
    level: 'silent',
    trace: () => {},
    debug: () => {},
    info: () => {},
    warn: () => {},
    error: () => {},
    fatal: () => {},
    child: () => ultraSilentLogger,
    log: () => {},
    success: () => {},
    warning: () => {},
    event: () => {},
    command: (...args) => {
        const timestamp = chalk.gray(`[${new Date().toLocaleTimeString()}]`);
        originalConsoleMethods.log(timestamp, chalk.cyan('‚ö°'), ...args);
    }
};

// Anti-viewonce configuration
const ANTIVIEWONCE_DATA_DIR = './data/antiviewonce';
const ANTIVIEWONCE_SAVE_DIR = './data/viewonce_messages';
const ANTIVIEWONCE_PRIVATE_DIR = './data/viewonce_private';
const ANTIVIEWONCE_HISTORY_FILE = join(ANTIVIEWONCE_SAVE_DIR, 'history.json');
const ANTIVIEWONCE_CONFIG_FILE = join(ANTIVIEWONCE_DATA_DIR, 'config.json');
const ANTIVIEWONCE_VERSION = '1.0.0';

const DEFAULT_ANTIVIEWONCE_CONFIG = {
    mode: 'private',
    autoSave: true,
    ownerJid: '',
    enabled: true,
    maxHistory: 500
};

// ====== DYNAMIC PREFIX SYSTEM ======
let prefixCache = DEFAULT_PREFIX;
let prefixHistory = [];
let isPrefixless = false;

function getCurrentPrefix() {
    return isPrefixless ? '' : prefixCache;
}

function savePrefixToFile(newPrefix) {
    try {
        const isNone = newPrefix === 'none' || newPrefix === '""' || newPrefix === "''" || newPrefix === '';
        
        const config = {
            prefix: isNone ? '' : newPrefix,
            isPrefixless: isNone,
            setAt: new Date().toISOString(),
            timestamp: Date.now(),
            version: VERSION,
            previousPrefix: prefixCache,
            previousIsPrefixless: isPrefixless
        };
        _cache_prefix_config = config;
        _saveConfigCache('prefix_config', config);
        
        const settings = {
            prefix: isNone ? '' : newPrefix,
            isPrefixless: isNone,
            prefixSetAt: new Date().toISOString(),
            prefixChangedAt: Date.now(),
            previousPrefix: prefixCache,
            previousIsPrefixless: isPrefixless,
            version: VERSION
        };
        _cache_bot_settings = settings;
        _saveConfigCache('bot_settings', settings);
        
        UltraCleanLogger.info(`Prefix settings saved: "${newPrefix}", prefixless: ${isNone}`);
        return true;
    } catch (error) {
        UltraCleanLogger.error(`Error saving prefix: ${error.message}`);
        return false;
    }
}

function loadPrefixFromFiles() {
    try {
        if (_cache_prefix_config) {
            const config = _cache_prefix_config;
            
            if (config.isPrefixless !== undefined) {
                isPrefixless = config.isPrefixless;
            }
            
            if (config.prefix !== undefined) {
                if (config.prefix.trim() === '' && config.isPrefixless) {
                    return '';
                } else if (config.prefix.trim() !== '') {
                    return config.prefix.trim();
                }
            }
        }
        
        if (_cache_bot_settings) {
            const settings = _cache_bot_settings;
            
            if (settings.isPrefixless !== undefined) {
                isPrefixless = settings.isPrefixless;
            }
            
            if (settings.prefix && settings.prefix.trim() !== '') {
                return settings.prefix.trim();
            }
        }
        
    } catch (error) {
        UltraCleanLogger.warning(`Error loading prefix: ${error.message}`);
    }
    
    return DEFAULT_PREFIX;
}

function updatePrefixImmediately(newPrefix) {
    const oldPrefix = prefixCache;
    const oldIsPrefixless = isPrefixless;
    
    const isNone = newPrefix === 'none' || newPrefix === '""' || newPrefix === "''" || newPrefix === '';
    
    if (isNone) {
        isPrefixless = true;
        prefixCache = '';
        
        UltraCleanLogger.success(`Prefixless mode enabled`);
    } else {
        if (!newPrefix || newPrefix.trim() === '') {
            UltraCleanLogger.error('Cannot set empty prefix');
            return { success: false, error: 'Empty prefix' };
        }
        
        if (newPrefix.length > 5) {
            UltraCleanLogger.error('Prefix too long (max 5 characters)');
            return { success: false, error: 'Prefix too long' };
        }
        
        const trimmedPrefix = newPrefix.trim();
        
        prefixCache = trimmedPrefix;
        isPrefixless = false;
        
        UltraCleanLogger.info(`Prefix changed to: "${trimmedPrefix}"`);
    }
    
    if (typeof global !== 'undefined') {
        global.prefix = getCurrentPrefix();
        global.CURRENT_PREFIX = getCurrentPrefix();
        global.isPrefixless = isPrefixless;
    }
    
    process.env.PREFIX = getCurrentPrefix();
    
    savePrefixToFile(newPrefix);
    
    prefixHistory.push({
        oldPrefix: oldIsPrefixless ? 'none' : oldPrefix,
        newPrefix: isPrefixless ? 'none' : prefixCache,
        isPrefixless: isPrefixless,
        oldIsPrefixless: oldIsPrefixless,
        timestamp: new Date().toISOString(),
        time: Date.now()
    });
    
    if (prefixHistory.length > 10) {
        prefixHistory = prefixHistory.slice(-10);
    }
    
    updateTerminalHeader();
    
    UltraCleanLogger.success(`Prefix updated: "${oldIsPrefixless ? 'none' : oldPrefix}" ‚Üí "${isPrefixless ? 'none (prefixless)' : prefixCache}"`);
    
    return {
        success: true,
        oldPrefix: oldIsPrefixless ? 'none' : oldPrefix,
        newPrefix: isPrefixless ? 'none' : prefixCache,
        isPrefixless: isPrefixless,
        timestamp: new Date().toISOString()
    };
}

// Platform detection
// Update the platform detection function
function detectPlatform() {
    // Check Heroku FIRST (most specific env variables)
    if (process.env.HEROKU_APP_NAME || 
        process.env.DYNO || 
        process.env.HEROKU_API_KEY ||
        (process.env.PORT && process.env.PORT !== '3000' && process.env.PORT !== '8080')) {
        return 'Heroku';
    }
    // Check Render
    else if (process.env.RENDER_SERVICE_ID || 
             process.env.RENDER_SERVICE_NAME ||
             process.env.RENDER) {
        return 'Render';
    }
    // Check Railway
    else if (process.env.RAILWAY_ENVIRONMENT ||
             process.env.RAILWAY_PROJECT_NAME ||
             process.env.RAILWAY_SERVICE_NAME) {
        return 'Railway';
    }
    // Check Replit
    else if (process.env.REPL_ID || 
             process.env.REPLIT_DB_URL ||
             process.env.REPLIT_USER ||
             process.env.REPL_SLUG) {
        return 'Replit';
    }
    // Check Vercel
    else if (process.env.VERCEL || 
             process.env.VERCEL_ENV ||
             process.env.VERCEL_URL) {
        return 'Vercel';
    }
    // Check Glitch
    else if (process.env.GLITCH_PROJECT_REMIX ||
             process.env.PROJECT_REMIX_CHAIN ||
             process.env.GLITCH) {
        return 'Glitch';
    }
    // Check Koyeb
    else if (process.env.KOYEB_APP ||
             process.env.KOYEB_REGION ||
             process.env.KOYEB_SERVICE) {
        return 'Koyeb';
    }
    // Check Cyclic
    else if (process.env.CYCLIC_URL ||
             process.env.CYCLIC_APP_ID ||
             process.env.CYCLIC_DB) {
        return 'Cyclic';
    }
    // Check Panel/Pterodactyl
    else if (process.env.PANEL ||
             process.env.PTERODACTYL ||
             process.env.NODE_ENV === 'production' && 
             (process.platform === 'linux' && !process.env.SSH_CONNECTION)) {
        return 'Panel/VPS';
    }
    // Check SSH/VPS
    else if (process.env.SSH_CONNECTION || 
             process.env.SSH_CLIENT ||
             (process.platform === 'linux' && process.env.USER === 'root')) {
        return 'VPS/SSH';
    }
    // Check OS
    else if (process.platform === 'win32') {
        return 'Windows PC';
    } else if (process.platform === 'darwin') {
        return 'MacOS';
    } else if (process.platform === 'linux') {
        return 'Linux Local';
    } else {
        return 'Local Machine';
    }
}
// ====== GLOBAL VARIABLES ======
let OWNER_NUMBER = null;
let OWNER_JID = null;
let OWNER_CLEAN_JID = null;
let OWNER_CLEAN_NUMBER = null;
let OWNER_LID = null;
let SOCKET_INSTANCE = null;
let isConnected = false;
let store = null;
let heartbeatInterval = null;
let lastActivityTime = Date.now();
let connectionAttempts = 0;
let connectionStableTimer = null;
let MAX_RETRY_ATTEMPTS = 10;
let BOT_MODE = 'public';
let WHITELIST = new Set();
let AUTO_LINK_ENABLED = true;
let AUTO_CONNECT_COMMAND_ENABLED = true;
let AUTO_ULTIMATE_FIX_ENABLED = true;
let isWaitingForPairingCode = false;
let RESTART_AUTO_FIX_ENABLED = true;
let hasSentRestartMessage = false;
let hasAutoConnectedOnStart = false;
let hasSentWelcomeMessage = false;
let initialCommandsLoaded = false;
let commandsLoaded = false;
let hasSentConnectionMessage = false;
let conflictCount = 0;
let isConflictRecovery = false;
let connectionOpenTime = 0;
let _allManagedIntervals = [];

let _lagCheckTs = Date.now();
setInterval(() => {
    const now = Date.now();
    const lag = now - _lagCheckTs - 5000;
    _lagCheckTs = now;
    if (lag > 1000) {
        originalConsoleMethods.log(`‚ö†Ô∏è [EVENT-LOOP] Lag detected: ${lag}ms`);
    }
}, 5000);

const DiskManager = {
    WARNING_MB: 200,
    CRITICAL_MB: 80,
    CHECK_INTERVAL: 3 * 60 * 1000,
    CLEANUP_INTERVAL: 10 * 60 * 1000,
    lastWarning: 0,
    lastCleanup: 0,
    isLow: false,

    _cachedDiskFree: null,
    _lastDiskCheck: 0,
    _diskCheckInFlight: false,
    getDiskFree() {
        return this._cachedDiskFree;
    },
    async getDiskFreeAsync() {
        const now = Date.now();
        if (now - this._lastDiskCheck < 60000 && this._cachedDiskFree !== null) {
            return this._cachedDiskFree;
        }
        if (this._diskCheckInFlight) return this._cachedDiskFree;
        this._diskCheckInFlight = true;
        try {
            const result = await new Promise((resolve, reject) => {
                exec('df -BM --output=avail . 2>/dev/null || df -m . 2>/dev/null', { encoding: 'utf8', timeout: 3000 }, (err, stdout) => {
                    if (err) reject(err);
                    else resolve(stdout);
                });
            });
            const match = result.match(/(\d+)M?\s*$/m);
            this._cachedDiskFree = match ? parseInt(match[1]) : null;
            this._lastDiskCheck = now;
        } catch {
            this._lastDiskCheck = now;
        } finally {
            this._diskCheckInFlight = false;
        }
        return this._cachedDiskFree;
    },

    getDirSize(dirPath) {
        let total = 0;
        try {
            if (!fs.existsSync(dirPath)) return 0;
            const entries = fs.readdirSync(dirPath);
            for (const entry of entries) {
                try {
                    const full = path.join(dirPath, entry);
                    const stat = fs.statSync(full);
                    if (stat.isFile()) total += stat.size;
                    else if (stat.isDirectory()) total += this.getDirSize(full);
                } catch {}
            }
        } catch {}
        return total;
    },

    getCleanupReport() {
        const sessionFiles = this._countSessionSignalFiles();
        const voMedia = 0;
        const adMedia = this.getDirSize('./data/antidelete/media');
        const statusMedia = this.getDirSize('./data/antidelete/status/media');
        const tempFiles = this.getDirSize('./temp') + this.getDirSize('./commands/temp');
        const backupFiles = this.getDirSize('./session_backup');
        const statusLogs = (() => { try { return _cache_status_logs ? JSON.stringify(_cache_status_logs).length : 0; } catch { return 0; } })();
        const freeMB = this.getDiskFree();
        return {
            freeMB,
            sessionSignalFiles: sessionFiles.count,
            sessionSignalMB: Math.round(sessionFiles.bytes / 1024 / 1024 * 10) / 10,
            viewonceMediaMB: Math.round(voMedia / 1024 / 1024 * 10) / 10,
            antideleteMediaMB: Math.round(adMedia / 1024 / 1024 * 10) / 10,
            statusMediaMB: Math.round(statusMedia / 1024 / 1024 * 10) / 10,
            tempFilesMB: Math.round(tempFiles / 1024 / 1024 * 10) / 10,
            backupMB: Math.round(backupFiles / 1024 / 1024 * 10) / 10,
            statusLogsMB: Math.round(statusLogs / 1024 / 1024 * 10) / 10
        };
    },

    _countSessionSignalFiles() {
        let count = 0, bytes = 0;
        try {
            if (!fs.existsSync(SESSION_DIR)) return { count: 0, bytes: 0 };
            const files = fs.readdirSync(SESSION_DIR);
            for (const file of files) {
                if (file.startsWith('sender-key-') || file.startsWith('pre-key-') || file.startsWith('app-state-sync-version-')) {
                    count++;
                    try { bytes += fs.statSync(path.join(SESSION_DIR, file)).size; } catch {}
                }
            }
        } catch {}
        return { count, bytes };
    },

    async _yieldBatch(i, batchSize = 50) {
        if (i > 0 && i % batchSize === 0) await new Promise(r => setImmediate(r));
    },

    async cleanSessionSignalFilesAsync(aggressive = false) {
        let removed = 0;
        try {
            if (!fs.existsSync(SESSION_DIR)) return 0;
            const files = await fs.promises.readdir(SESSION_DIR);
            const senderKeys = files.filter(f => f.startsWith('sender-key-'));
            const preKeys = files.filter(f => f.startsWith('pre-key-'));
            const appSync = files.filter(f => f.startsWith('app-state-sync-version-'));

            const senderLimit = aggressive ? 20 : 80;
            const preKeyLimit = aggressive ? 20 : 80;
            const appSyncLimit = aggressive ? 5 : 15;

            const removeFiles = async (list, limit) => {
                if (list.length <= limit) return 0;
                const toRemove = list.slice(0, list.length - limit);
                let count = 0;
                for (let i = 0; i < toRemove.length; i++) {
                    try { await fs.promises.unlink(path.join(SESSION_DIR, toRemove[i])); count++; } catch {}
                    await this._yieldBatch(i);
                }
                return count;
            };
            removed += await removeFiles(senderKeys, senderLimit);
            removed += await removeFiles(preKeys, preKeyLimit);
            removed += await removeFiles(appSync, appSyncLimit);
        } catch {}
        return removed;
    },

    async cleanOldMediaAsync(dirPath, maxAgeDays = 3, aggressive = false) {
        let removed = 0;
        try {
            if (!fs.existsSync(dirPath)) return 0;
            const now = Date.now();
            const maxAge = (aggressive ? 1 : maxAgeDays) * 24 * 60 * 60 * 1000;
            const files = await fs.promises.readdir(dirPath);
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                if (file.endsWith('.json')) continue;
                try {
                    const full = path.join(dirPath, file);
                    const stat = await fs.promises.stat(full);
                    if (stat.isFile() && (now - stat.mtimeMs) > maxAge) {
                        await fs.promises.unlink(full);
                        removed++;
                    }
                } catch {}
                await this._yieldBatch(i);
            }
        } catch {}
        return removed;
    },

    async cleanTempFilesAsync(aggressive = false) {
        let removed = 0;
        const tempDirs = [
            './temp',
            './temp/ig',
            './temp/snapchat',
            './temp/compressed',
            './temp/apk',
            './commands/temp',
            './viewonce_stealth',
            './viewonce_downloads',
            './temp_stickers',
            './temp_url_uploads',
            './collected_stickers',
            './sticker_packs'
        ];
        const now = Date.now();
        const maxAge = aggressive ? 2 * 60 * 1000 : 15 * 60 * 1000;
        for (const dir of tempDirs) {
            try {
                if (!fs.existsSync(dir)) continue;
                const files = await fs.promises.readdir(dir);
                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    try {
                        const full = path.join(dir, file);
                        const stat = await fs.promises.stat(full);
                        if (stat.isFile() && (now - stat.mtimeMs) > maxAge) {
                            await fs.promises.unlink(full);
                            removed++;
                        }
                    } catch {}
                    await this._yieldBatch(i);
                }
            } catch {}
        }
        return removed;
    },

    async cleanBackupsAsync() {
        let removed = 0;
        try {
            if (!fs.existsSync('./session_backup')) return 0;
            const files = await fs.promises.readdir('./session_backup');
            for (let i = 0; i < files.length; i++) {
                try { await fs.promises.unlink(path.join('./session_backup', files[i])); removed++; } catch {}
                await this._yieldBatch(i);
            }
            try { await fs.promises.rmdir('./session_backup'); } catch {}
        } catch {}
        return removed;
    },

    async truncateStatusLogsAsync() {
        try {
            const logFile = './data/status_detection_logs.json';
            if (!fs.existsSync(logFile)) return false;
            const raw = await fs.promises.readFile(logFile, 'utf8');
            const data = JSON.parse(raw);
            if (data.logs && data.logs.length > 50) {
                data.logs = data.logs.slice(-50);
                await fs.promises.writeFile(logFile, JSON.stringify(data));
                return true;
            }
        } catch {}
        return false;
    },

    async cleanStatusMediaAsync(aggressive = false) {
        let removed = 0;
        const statusMediaDir = './data/antidelete/status/media';
        try {
            if (!fs.existsSync(statusMediaDir)) return 0;
            const now = Date.now();
            const maxAge = (aggressive ? 1 * 60 * 60 * 1000 : 6 * 60 * 60 * 1000);
            const files = await fs.promises.readdir(statusMediaDir);
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                try {
                    const full = path.join(statusMediaDir, file);
                    const stat = await fs.promises.stat(full);
                    if (stat.isFile() && (now - stat.mtimeMs) > maxAge) {
                        await fs.promises.unlink(full);
                        removed++;
                    }
                } catch {}
                await this._yieldBatch(i);
            }
        } catch {}
        return removed;
    },

    runCleanup(aggressive = false) {
        this.runCleanupAsync(aggressive).catch(() => {});
    },

    async cleanLogFilesAsync() {
        let removed = 0;
        try {
            const logDirs = ['.', './logs'];
            const now = Date.now();
            for (const dir of logDirs) {
                try {
                    if (!fs.existsSync(dir)) continue;
                    const files = await fs.promises.readdir(dir);
                    for (const file of files) {
                        if (!file.endsWith('.log')) continue;
                        try {
                            const full = path.join(dir, file);
                            const stat = await fs.promises.stat(full);
                            if (stat.isFile() && (stat.size > 5 * 1024 * 1024 || (now - stat.mtimeMs) > 24 * 60 * 60 * 1000)) {
                                await fs.promises.unlink(full);
                                removed++;
                            }
                        } catch {}
                    }
                } catch {}
            }
        } catch {}
        return removed;
    },

    async runCleanupAsync(aggressive = false) {
        const yieldToLoop = () => new Promise(r => setImmediate(r));
        const results = {};
        results.sessionFiles = await this.cleanSessionSignalFilesAsync(aggressive);
        await yieldToLoop();
        results.viewonceMedia = await this.cleanOldMediaAsync('./data/viewonce_messages', 1, aggressive) + await this.cleanOldMediaAsync('./data/viewonce_private', 1, aggressive);
        await yieldToLoop();
        results.antideleteMedia = await this.cleanOldMediaAsync('./data/antidelete/media', 1, aggressive);
        await yieldToLoop();
        results.statusMedia = await this.cleanStatusMediaAsync(aggressive);
        await yieldToLoop();
        results.tempFiles = await this.cleanTempFilesAsync(aggressive);
        await yieldToLoop();
        results.backups = aggressive ? await this.cleanBackupsAsync() : 0;
        results.statusLogs = await this.truncateStatusLogsAsync() ? 1 : 0;
        results.logFiles = await this.cleanLogFilesAsync();
        const total = Object.values(results).reduce((a, b) => a + b, 0);
        if (total > 0) {
            UltraCleanLogger.info(`üßπ Disk cleanup: removed ${total} items (session: ${results.sessionFiles}, viewonce: ${results.viewonceMedia}, antidelete: ${results.antideleteMedia}, status-media: ${results.statusMedia}, temp: ${results.tempFiles}, backups: ${results.backups}, logs: ${results.logFiles})`);
        }
        this.lastCleanup = Date.now();
        return results;
    },

    async monitorAsync() {
        const freeMB = await this.getDiskFreeAsync();
        if (freeMB === null) return;

        if (freeMB < this.CRITICAL_MB) {
            this.isLow = true;
            UltraCleanLogger.error(`üö® CRITICAL: Only ${freeMB}MB disk space left! Running aggressive cleanup...`);
            await this.runCleanupAsync(true);
        } else if (freeMB < this.WARNING_MB) {
            this.isLow = true;
            if (Date.now() - this.lastWarning > 30 * 60 * 1000) {
                UltraCleanLogger.warning(`‚ö†Ô∏è Low disk space: ${freeMB}MB remaining. Running cleanup...`);
                this.lastWarning = Date.now();
            }
            await this.runCleanupAsync(false);
        } else {
            this.isLow = false;
        }
    },

    _intervals: [],
    _started: false,
    async start() {
        if (this._started) return;
        this._started = true;
        const freeMB = await this.getDiskFreeAsync();
        if (freeMB !== null && freeMB < this.WARNING_MB) {
            UltraCleanLogger.warning(`‚ö†Ô∏è Low disk on startup: ${freeMB}MB free. Running immediate cleanup...`);
            await this.runCleanupAsync(freeMB < this.CRITICAL_MB);
        } else {
            this.runCleanupAsync(false).catch(() => {});
        }
        this._intervals.push(setInterval(() => this.monitorAsync().catch(() => {}), this.CHECK_INTERVAL));
        this._intervals.push(setInterval(() => {
            if (!this.isLow) this.runCleanupAsync(false).catch(() => {});
        }, this.CLEANUP_INTERVAL));
        UltraCleanLogger.info('üíæ Disk space manager: ‚úÖ ACTIVE');
    }
};


function safeWriteFile(filePath, data) {
    const content = (typeof data === 'string' || Buffer.isBuffer(data)) ? data : JSON.stringify(data, null, 2);
    try {
        fs.writeFileSync(filePath, content);
        return true;
    } catch (err) {
        if (err.code === 'ENOSPC') {
            UltraCleanLogger.error(`üíæ Disk full! Cannot write ${filePath}. Running emergency cleanup...`);
            DiskManager._lastDiskCheck = 0;
            DiskManager.runCleanup(true);
            try {
                fs.writeFileSync(filePath, content);
                return true;
            } catch {
                return false;
            }
        }
        throw err;
    }
}

async function safeWriteFileAsync(filePath, data) {
    const fsPromises = fs.promises;
    try {
        await fsPromises.writeFile(filePath, typeof data === 'string' ? data : JSON.stringify(data, null, 2));
        return true;
    } catch (err) {
        if (err.code === 'ENOSPC') {
            UltraCleanLogger.error(`üíæ Disk full! Cannot write ${filePath}. Running emergency cleanup...`);
            DiskManager.runCleanup(true);
            try {
                await fsPromises.writeFile(filePath, typeof data === 'string' ? data : JSON.stringify(data, null, 2));
                return true;
            } catch {
                return false;
            }
        }
        throw err;
    }
}

// Utility functions
const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

// ====== JID/LID HANDLING SYSTEM ======
class JidManager {
    constructor() {
        this.ownerJids = new Set();
        this.ownerLids = new Set();
        this.owner = null;
        this.loadOwnerData();
        this.loadWhitelist();
        
        UltraCleanLogger.success('JID Manager initialized');
    }
    
    loadOwnerData() {
        try {
            const data = _cache_owner_data;
            if (data) {
                const ownerJid = data.OWNER_JID;
                if (ownerJid) {
                    const cleaned = this.cleanJid(ownerJid);
                    
                    this.owner = {
                        rawJid: ownerJid,
                        cleanJid: cleaned.cleanJid,
                        cleanNumber: cleaned.cleanNumber,
                        isLid: cleaned.isLid,
                        linkedAt: data.linkedAt || new Date().toISOString()
                    };
                    
                    this.ownerJids.clear();
                    this.ownerLids.clear();
                    
                    this.ownerJids.add(cleaned.cleanJid);
                    this.ownerJids.add(ownerJid);
                    
                    if (cleaned.isLid) {
                        this.ownerLids.add(ownerJid);
                        const lidNumber = ownerJid.split('@')[0];
                        this.ownerLids.add(lidNumber);
                        OWNER_LID = ownerJid;
                    }
                    
                    OWNER_JID = ownerJid;
                    OWNER_NUMBER = cleaned.cleanNumber;
                    OWNER_CLEAN_JID = cleaned.cleanJid;
                    OWNER_CLEAN_NUMBER = cleaned.cleanNumber;
                    
                    UltraCleanLogger.success(`Loaded owner: ${cleaned.cleanJid}`);
                }
            }
        } catch {
            // Silent fail
        }
    }
    
    loadWhitelist() {
        try {
            const data = _cache_whitelist;
            if (data && data.whitelist && Array.isArray(data.whitelist)) {
                data.whitelist.forEach(item => {
                    WHITELIST.add(item);
                });
            }
        } catch {
            // Silent fail
        }
    }
    
    cleanJid(jid) {
        if (!jid) return { cleanJid: '', cleanNumber: '', raw: jid, isLid: false };
        
        const isLid = jid.includes('@lid');
        if (isLid) {
            const lidFull = jid.split('@')[0];
            const lidNumber = lidFull.split(':')[0];
            return {
                raw: jid,
                cleanJid: jid,
                cleanNumber: lidNumber,
                isLid: true
            };
        }
        
        const [numberPart] = jid.split('@')[0].split(':');
        const serverPart = jid.split('@')[1] || 's.whatsapp.net';
        
        const cleanNumber = numberPart.replace(/[^0-9]/g, '');
        const normalizedNumber = cleanNumber.startsWith('0') ? cleanNumber.substring(1) : cleanNumber;
        const cleanJid = `${normalizedNumber}@${serverPart}`;
        
        return {
            raw: jid,
            cleanJid: cleanJid,
            cleanNumber: normalizedNumber,
            isLid: false
        };
    }
    
    isOwner(msg) {
        if (!msg || !msg.key) return false;
        
        const chatJid = msg.key.remoteJid;
        const participant = msg.key.participant;
        const senderJid = participant || chatJid;
        const cleaned = this.cleanJid(senderJid);
        
        if (!this.owner || !this.owner.cleanNumber) {
            return false;
        }
        
        if (this.ownerJids.has(cleaned.cleanJid) || this.ownerJids.has(senderJid)) {
            return true;
        }
        
        if (cleaned.isLid) {
            const lidNumber = cleaned.cleanNumber;
            if (this.ownerLids.has(senderJid) || this.ownerLids.has(lidNumber)) {
                return true;
            }
            
            if (OWNER_LID && (senderJid === OWNER_LID || lidNumber === OWNER_LID.split('@')[0])) {
                return true;
            }
        }
        
        return false;
    }
    
    isSudo(msg) {
        if (!msg || !msg.key) return false;
        const chatJid = msg.key.remoteJid;
        const participant = msg.key.participant;
        const senderJid = participant || chatJid;
        
        if (isSudoJid(senderJid)) return true;
        
        const cleaned = this.cleanJid(senderJid);
        if (isSudoNumber(cleaned.cleanNumber)) return true;
        
        const rawNum = senderJid.split('@')[0].split(':')[0];
        if (rawNum !== cleaned.cleanNumber && isSudoNumber(rawNum)) return true;
        
        if (senderJid.includes('@lid')) {
            const phone = resolvePhoneFromLid(senderJid);
            if (phone && isSudoNumber(phone)) {
                mapLidToPhone(rawNum, phone);
                return true;
            }
        }
        
        if (isSudoByLid(rawNum)) return true;
        if (isSudoByLid(cleaned.cleanNumber)) return true;
        
        const lidNum = senderJid.split('@')[0].split(':')[0];
        const cachedPhone = lidPhoneCache.get(lidNum);
        if (cachedPhone && isSudoNumber(cachedPhone)) return true;

        if (rawNum.length > 15) {
            for (const [cachedLid, cachedPhoneVal] of lidPhoneCache) {
                if (cachedLid === rawNum && isSudoNumber(cachedPhoneVal)) return true;
            }
        }
        
        return false;
    }

    async isSudoAsync(msg, sock) {
        if (this.isSudo(msg)) return true;
        if (!msg || !msg.key) return false;
        
        const chatJid = msg.key.remoteJid;
        const participant = msg.key.participant;
        const senderJid = participant || chatJid;
        
        const { sudoers } = getSudoList();
        if (sudoers.length === 0) return false;

        const senderLidNum = senderJid.split('@')[0].split(':')[0];
        const senderFull = senderJid.split('@')[0];

        try {
            if (chatJid.includes('@g.us') && sock) {
                await buildLidMapFromGroup(chatJid, sock);
                
                const resolved = lidPhoneCache.get(senderLidNum) || lidPhoneCache.get(senderFull) || getPhoneFromLid(senderLidNum) || getPhoneFromLid(senderFull);
                if (resolved && isSudoNumber(resolved)) {
                    return true;
                }
                
                if (this.isSudo(msg)) return true;
            }
        } catch (err) {
            UltraCleanLogger.info(`‚ö†Ô∏è isSudoAsync group error: ${err.message}`);
        }

        try {
            if (!chatJid.includes('@g.us') && sock && senderJid.includes('@lid')) {
                const groups = await sock.groupFetchAllParticipating();
                if (groups) {
                    for (const [groupId, groupData] of Object.entries(groups)) {
                        const participants = groupData.participants || [];
                        for (const p of participants) {
                            const { phoneNum, lidNum } = extractParticipantInfo(p, sock);
                            if (phoneNum && lidNum && phoneNum !== lidNum) {
                                cacheLidPhone(lidNum, phoneNum);
                            }
                        }
                        const resolved = lidPhoneCache.get(senderLidNum) || lidPhoneCache.get(senderFull) || getPhoneFromLid(senderLidNum) || getPhoneFromLid(senderFull);
                        if (resolved && isSudoNumber(resolved)) {
                            UltraCleanLogger.info(`üîë Sudo LID resolved from group scan: +${resolved}`);
                            return true;
                        }
                    }
                }
            }
        } catch (err) {
            UltraCleanLogger.info(`‚ö†Ô∏è isSudoAsync DM scan error: ${err.message}`);
        }
        
        return false;
    }
    
    setNewOwner(newJid, isAutoLinked = false) {
        try {
            const cleaned = this.cleanJid(newJid);
            
            this.ownerJids.clear();
            this.ownerLids.clear();
            WHITELIST.clear();
            
            this.owner = {
                rawJid: newJid,
                cleanJid: cleaned.cleanJid,
                cleanNumber: cleaned.cleanNumber,
                isLid: cleaned.isLid,
                linkedAt: new Date().toISOString(),
                autoLinked: isAutoLinked
            };
            
            this.ownerJids.add(cleaned.cleanJid);
            this.ownerJids.add(newJid);
            
            if (cleaned.isLid) {
                this.ownerLids.add(newJid);
                const lidNumber = newJid.split('@')[0];
                this.ownerLids.add(lidNumber);
                OWNER_LID = newJid;
            } else {
                OWNER_LID = null;
            }
            
            OWNER_JID = newJid;
            OWNER_NUMBER = cleaned.cleanNumber;
            OWNER_CLEAN_JID = cleaned.cleanJid;
            OWNER_CLEAN_NUMBER = cleaned.cleanNumber;
            
            const ownerData = {
                OWNER_JID: newJid,
                OWNER_NUMBER: cleaned.cleanNumber,
                OWNER_CLEAN_JID: cleaned.cleanJid,
                OWNER_CLEAN_NUMBER: cleaned.cleanNumber,
                ownerLID: cleaned.isLid ? newJid : null,
                linkedAt: new Date().toISOString(),
                autoLinked: isAutoLinked,
                previousOwnerCleared: true,
                version: VERSION
            };
            
            _cache_owner_data = ownerData;
            _saveConfigCache('owner_data', ownerData);
            
            UltraCleanLogger.success(`New owner set: ${cleaned.cleanJid}`);
            
            return {
                success: true,
                owner: this.owner,
                isLid: cleaned.isLid
            };
            
        } catch {
            return { success: false, error: 'Failed to set new owner' };
        }
    }
    
    getOwnerInfo() {
        return {
            ownerJid: this.owner?.cleanJid || null,
            ownerNumber: this.owner?.cleanNumber || null,
            ownerLid: OWNER_LID || null,
            jidCount: this.ownerJids.size,
            lidCount: this.ownerLids.size,
            whitelistCount: WHITELIST.size,
            isLid: this.owner?.isLid || false,
            linkedAt: this.owner?.linkedAt || null
        };
    }
}

const jidManager = new JidManager();

// ====== NEW MEMBER DETECTION SYSTEM ======
class NewMemberDetector {
    constructor() {
        this.enabled = true;
        this.detectedMembers = new Map();
        this.groupMembersCache = new Map();
        this.loadDetectionData();
        
        UltraCleanLogger.success('New Member Detector initialized');
    }
    
    loadDetectionData() {
        try {
            if (_cache_member_detection && _cache_member_detection.detectedMembers) {
                for (const [groupId, members] of Object.entries(_cache_member_detection.detectedMembers)) {
                    this.detectedMembers.set(groupId, members);
                }
                UltraCleanLogger.info(`üìä Loaded ${this.detectedMembers.size} groups member data`);
                return;
            }
            supabaseDb.getConfig('member_detection', {}).then(data => {
                try {
                    _cache_member_detection = data;
                    if (data && data.detectedMembers) {
                        for (const [groupId, members] of Object.entries(data.detectedMembers)) {
                            this.detectedMembers.set(groupId, members);
                        }
                        UltraCleanLogger.info(`üìä Loaded ${this.detectedMembers.size} groups member data`);
                    }
                } catch {}
            }).catch(err => {
                UltraCleanLogger.warning(`Could not load member detection data: ${err.message}`);
            });
        } catch (error) {
            UltraCleanLogger.warning(`Could not load member detection data: ${error.message}`);
        }
    }
    
    saveDetectionData() {
        try {
            const data = {
                detectedMembers: {},
                updatedAt: new Date().toISOString(),
                totalGroups: this.detectedMembers.size
            };
            
            for (const [groupId, members] of this.detectedMembers.entries()) {
                data.detectedMembers[groupId] = members;
            }
            
            _cache_member_detection = data;
            supabaseDb.setConfig('member_detection', data).catch(err => {
                UltraCleanLogger.warning(`Could not save member detection data: ${err.message}`);
            });
        } catch (error) {
            UltraCleanLogger.warning(`Could not save member detection data: ${error.message}`);
        }
    }
    
    async detectNewMembers(sock, groupUpdate) {
        try {
            if (!this.enabled) return null;
            
            const groupId = groupUpdate.id;
            const action = groupUpdate.action;
            
            if (action === 'add' || action === 'invite') {
                const participants = groupUpdate.participants || [];
                
                const metadata = await sock.groupMetadata(groupId);
                const groupName = metadata.subject || 'Unknown Group';
                
                let cachedMembers = this.groupMembersCache.get(groupId) || new Set();
                
                const newMembers = [];
                for (const participant of participants) {
                    let userJid;
                    if (typeof participant === 'string') {
                        userJid = participant.includes('@') ? participant : null;
                    } else if (participant && typeof participant === 'object') {
                        const jid = participant.jid || participant.id || participant.userJid || participant.participant || participant.user;
                        if (typeof jid === 'string' && jid.includes('@')) userJid = jid;
                        else if (typeof jid === 'string' && /^\d+$/.test(jid)) userJid = `${jid}@s.whatsapp.net`;
                        else userJid = null;
                    } else {
                        userJid = null;
                    }
                    if (!userJid) continue;
                    
                    if (!cachedMembers.has(userJid)) {
                        try {
                            const userInfo = await sock.onWhatsApp(userJid);
                            const userName = userInfo[0]?.name || userJid.split('@')[0];
                            const userNumber = userJid.split('@')[0];
                            
                            newMembers.push({
                                jid: userJid,
                                name: userName,
                                number: userNumber,
                                addedAt: new Date().toISOString(),
                                timestamp: Date.now(),
                                action: action,
                                addedBy: groupUpdate.actor || 'unknown'
                            });
                            
                            cachedMembers.add(userJid);
                            
                            this.showMemberNotification(groupName, userName, userNumber, action);
                            
                        } catch (error) {
                            UltraCleanLogger.warning(`Could not get user info for ${userJid}: ${error.message}`);
                        }
                    }
                }
                
                this.groupMembersCache.set(groupId, cachedMembers);
                
                if (newMembers.length > 0) {
                    const groupEvents = this.detectedMembers.get(groupId) || [];
                    groupEvents.push(...newMembers);
                    this.detectedMembers.set(groupId, groupEvents.slice(-50));
                    
                    if (Math.random() < 0.2) {
                        this.saveDetectionData();
                    }
                    
                    return newMembers;
                }
            }
            
            return null;
            
        } catch (error) {
            UltraCleanLogger.error(`Member detection error: ${error.message}`);
            return null;
        }
    }
    
    showMemberNotification(groupName, userName, userNumber, action) {
        const actionEmoji = action === 'add' ? '‚ûï' : 'üì®';
        const actionText = action === 'add' ? 'ADDED' : 'INVITED';
        
        logMember(`${actionEmoji} ${actionText}: ${userName} (+${userNumber})`);
        logGroup(`üë• Group: ${groupName}`);
    }
    
    async checkWelcomeSystem(sock, groupId, newMembers) {
        try {
            const welcomeData = this.loadWelcomeData();
            const groupWelcome = welcomeData.groups?.[groupId];
            
            if (groupWelcome?.enabled) {
                for (const member of newMembers) {
                    await this.sendWelcomeMessage(sock, groupId, member.jid, groupWelcome.message);
                }
            }
        } catch (error) {
            UltraCleanLogger.warning(`Welcome system check failed: ${error.message}`);
        }
    }
    
    async sendWelcomeMessage(sock, groupId, userId, message) {
        try {
            const userInfo = await sock.onWhatsApp(userId);
            const userName = userInfo[0]?.name || userId.split('@')[0];
            
            const metadata = await sock.groupMetadata(groupId);
            const memberCount = metadata.participants.length;
            const groupName = metadata.subject || "Our Group";
            
            const welcomeText = this.replaceWelcomeVariables(message, {
                name: userName,
                group: groupName,
                members: memberCount,
                mention: `@${userId.split('@')[0]}`
            });
            
            let profilePic = null;
            try {
                profilePic = await sock.profilePictureUrl(userId, 'image');
            } catch {
                profilePic = 'https://cdn.pixabay.com/photo/2015/10/05/22/37/blank-profile-picture-973460_1280.png';
            }
            
            await sock.sendMessage(groupId, {
                image: { url: profilePic },
                caption: welcomeText,
                mentions: [userId],
                contextInfo: {
                    mentionedJid: [userId]
                }
            });
            
            const welcomeData = this.loadWelcomeData();
            if (welcomeData.groups?.[groupId]) {
                welcomeData.groups[groupId].lastWelcome = Date.now();
                this.saveWelcomeData(welcomeData);
            }
            
            UltraCleanLogger.info(`‚úÖ Welcome sent to ${userName} in ${groupName}`);
            
        } catch (error) {
            UltraCleanLogger.warning(`Could not send welcome message: ${error.message}`);
        }
    }
    
    replaceWelcomeVariables(message, variables) {
        return message
            .replace(/{name}/g, variables.name)
            .replace(/{group}/g, variables.group)
            .replace(/{members}/g, variables.members)
            .replace(/{mention}/g, variables.mention);
    }
    
    loadWelcomeData() {
        try {
            if (_cache_welcome_data) {
                return _cache_welcome_data;
            }
        } catch (error) {
            UltraCleanLogger.warning(`Error loading welcome data: ${error.message}`);
        }
        
        return {
            groups: {},
            version: '1.0',
            created: new Date().toISOString()
        };
    }
    
    saveWelcomeData(data) {
        try {
            data.updated = new Date().toISOString();
            _cache_welcome_data = data;
            _saveConfigCache('welcome_data', data);
            return true;
        } catch (error) {
            UltraCleanLogger.warning(`Error saving welcome data: ${error.message}`);
            return false;
        }
    }
    
    getStats() {
        let totalEvents = 0;
        for (const events of this.detectedMembers.values()) {
            totalEvents += events.length;
        }
        
        return {
            enabled: this.enabled,
            totalGroups: this.detectedMembers.size,
            totalEvents: totalEvents,
            cachedGroups: this.groupMembersCache.size
        };
    }
}

const memberDetector = new NewMemberDetector();

// ====== AUTO GROUP JOIN SYSTEM ======
// class AutoGroupJoinSystem {
//     constructor() {
//         this.initialized = false;
//         this.invitedUsers = new Set();
//         this.loadInvitedUsers();
//         UltraCleanLogger.success('Auto-Join System initialized');
//     }

//     loadInvitedUsers() {
//         try {
//             if (fs.existsSync(AUTO_JOIN_LOG_FILE)) {
//                 const data = JSON.parse(fs.readFileSync(AUTO_JOIN_LOG_FILE, 'utf8'));
//                 data.users.forEach(user => this.invitedUsers.add(user));
//                 UltraCleanLogger.info(`üìä Loaded ${this.invitedUsers.size} previously invited users`);
//             }
//         } catch (error) {
//             // Silent fail
//         }
//     }

//     saveInvitedUser(userJid) {
//         try {
//             this.invitedUsers.add(userJid);
            
//             let data = { 
//                 users: [], 
//                 lastUpdated: new Date().toISOString(),
//                 totalInvites: 0
//             };
            
//             if (fs.existsSync(AUTO_JOIN_LOG_FILE)) {
//                 data = JSON.parse(fs.readFileSync(AUTO_JOIN_LOG_FILE, 'utf8'));
//             }
            
//             if (!data.users.includes(userJid)) {
//                 data.users.push(userJid);
//                 data.totalInvites = data.users.length;
//                 data.lastUpdated = new Date().toISOString();
//                 fs.writeFileSync(AUTO_JOIN_LOG_FILE, JSON.stringify(data, null, 2));
//                 UltraCleanLogger.success(`‚úÖ Saved invited user: ${userJid}`);
//             }
//         } catch (error) {
//             UltraCleanLogger.error(`‚ùå Error saving invited user: ${error.message}`);
//         }
//     }

//     isOwner(userJid, jidManager) {
//         if (!jidManager.owner || !jidManager.owner.cleanNumber) return false;
//         return userJid === jidManager.owner.cleanJid || 
//                userJid === jidManager.owner.rawJid ||
//                userJid.includes(jidManager.owner.cleanNumber);
//     }

//     async sendWelcomeMessage(sock, userJid) {
//         if (!SEND_WELCOME_MESSAGE) return;
        
//         try {
//             await sock.sendMessage(userJid, {
//                 text: `üéâ *WELCOME TO WOLFBOT!*\n\n` +
//                       `Thank you for connecting with WolfBot! ü§ñ\n\n` +
//                       `‚ú® *Features Available:*\n` +
//                       `‚Ä¢ Multiple command categories\n` +
//                       `‚Ä¢ Group management tools\n` +
//                       `‚Ä¢ Media downloading\n` +
//                       `‚Ä¢ Anti-ViewOnce system\n` +
//                       `‚Ä¢ And much more!\n\n` +
//                       `You're being automatically invited to join our official community group...\n` +
//                       `Please wait a moment... ‚è≥`
//             });
//         } catch (error) {
//             UltraCleanLogger.error(`‚ùå Could not send welcome message: ${error.message}`);
//         }
//     }

//     async sendGroupInvitation(sock, userJid, isOwner = false) {
//         try {
//             const message = isOwner 
//                 ? `üëë *OWNER AUTO-JOIN*\n\n` +
//                   `You are being automatically added to the group...\n` +
//                   `üîó ${GROUP_LINK}`
//                 : `üîó *GROUP INVITATION*\n\n` +
//                   `You've been invited to join our community!\n\n` +
//                   `*Group Name:* ${GROUP_NAME}\n` +
//                   `*Features:*\n` +
//                   `‚Ä¢ Bot support & updates\n` +
//                   `‚Ä¢ Community chat\n` +
//                   `‚Ä¢ Exclusive features\n` +
//                   `‚Ä¢ Anti-ViewOnce protection\n\n` +
//                   `Click to join: ${GROUP_LINK}`;
            
//             await sock.sendMessage(userJid, { text: message });
//             return true;
//         } catch (error) {
//             UltraCleanLogger.error(`‚ùå Could not send group invitation: ${error.message}`);
//             return false;
//         }
//     }

//     async attemptAutoAdd(sock, userJid, isOwner = false) {
//         try {
//             UltraCleanLogger.info(`üîÑ Attempting to auto-add ${isOwner ? 'owner' : 'user'} ${userJid} to group...`);
            
//             let groupId;
//             try {
//                 groupId = await sock.groupAcceptInvite(GROUP_INVITE_CODE);
//                 UltraCleanLogger.success(`‚úÖ Successfully accessed group: ${groupId}`);
//             } catch (inviteError) {
//                 UltraCleanLogger.warning(`‚ö†Ô∏è Could not accept invite, trying direct add: ${inviteError.message}`);
//                 throw new Error('Could not access group with invite code');
//             }
            
//             await sock.groupParticipantsUpdate(groupId, [userJid], 'add');
//             UltraCleanLogger.success(`‚úÖ Successfully added ${userJid} to group`);
            
//             const successMessage = isOwner
//                 ? `‚úÖ *SUCCESSFULLY JOINED!*\n\n` +
//                   `You have been automatically added to the group!\n` +
//                   `The bot is now fully operational there. üéâ`
//                 : `‚úÖ *WELCOME TO THE GROUP!*\n\n` +
//                   `You have been successfully added to ${GROUP_NAME}!\n` +
//                   `Please introduce yourself when you join. üëã`;
            
//             await sock.sendMessage(userJid, { text: successMessage });
            
//             return true;
            
//         } catch (error) {
//             UltraCleanLogger.error(`‚ùå Auto-add failed for ${userJid}: ${error.message}`);
            
//             const manualMessage = isOwner
//                 ? `‚ö†Ô∏è *MANUAL JOIN REQUIRED*\n\n` +
//                   `Could not auto-add you to the group.\n\n` +
//                   `*Please join manually:*\n` +
//                   `${GROUP_LINK}\n\n` +
//                   `Once joined, the bot will work there immediately.`
//                 : `‚ö†Ô∏è *MANUAL JOIN REQUIRED*\n\n` +
//                   `Could not auto-add you to the group.\n\n` +
//                   `*Please join manually:*\n` +
//                   `${GROUP_LINK}\n\n` +
//                   `We'd love to have you in our community!`;
            
//             await sock.sendMessage(userJid, { text: manualMessage });
            
//             return false;
//         }
//     }

//     async autoJoinGroup(sock, userJid) {
//         if (!AUTO_JOIN_ENABLED) {
//             UltraCleanLogger.info('Auto-join is disabled in settings');
//             return false;
//         }
        
//         if (this.invitedUsers.has(userJid)) {
//             UltraCleanLogger.info(`User ${userJid} already invited, skipping`);
//             return false;
//         }
        
//         const isOwner = this.isOwner(userJid, jidManager);
//         UltraCleanLogger.info(`${isOwner ? 'üëë Owner' : 'üë§ User'} ${userJid} connected, initiating auto-join...`);
        
//         await this.sendWelcomeMessage(sock, userJid);
        
//         await new Promise(resolve => setTimeout(resolve, AUTO_JOIN_DELAY));
        
//         await this.sendGroupInvitation(sock, userJid, isOwner);
        
//         await new Promise(resolve => setTimeout(resolve, 3000));
        
//         const success = await this.attemptAutoAdd(sock, userJid, isOwner);
        
//         this.saveInvitedUser(userJid);
        
//         return success;
//     }

//     async startupAutoJoin(sock) {
//         if (!AUTO_JOIN_ENABLED || !jidManager.owner) return;
        
//         try {
//             UltraCleanLogger.info('üöÄ Running startup auto-join check...');
            
//             const ownerJid = jidManager.owner.cleanJid;
            
//             if (jidManager.owner.autoJoinedGroup) {
//                 UltraCleanLogger.info('üëë Owner already auto-joined previously');
//                 return;
//             }
            
//             UltraCleanLogger.info(`üëë Attempting to auto-join owner ${ownerJid} to group...`);
            
//             await new Promise(resolve => setTimeout(resolve, 10000));
            
//             const success = await this.autoJoinGroup(sock, ownerJid);
            
//             if (success) {
//                 UltraCleanLogger.success('‚úÖ Startup auto-join completed successfully');
//                 if (jidManager.owner) {
//                     jidManager.owner.autoJoinedGroup = true;
//                     jidManager.owner.lastAutoJoin = new Date().toISOString();
//                 }
//             } else {
//                 UltraCleanLogger.warning('‚ö†Ô∏è Startup auto-join failed');
//             }
            
//         } catch (error) {
//             UltraCleanLogger.error(`Startup auto-join error: ${error.message}`);
//         }
//     }
// }

// const autoGroupJoinSystem = new AutoGroupJoinSystem();



// ====== ULTIMATE FIX SYSTEM ======
class UltimateFixSystem {
    constructor() {
        this.fixedJids = new Set();
        this.fixApplied = false;
        this.restartFixAttempted = false;
    }
    
    async applyUltimateFix(sock, senderJid, cleaned, isFirstUser = false, isRestart = false) {
        try {
            const fixType = isRestart ? 'RESTART' : (isFirstUser ? 'FIRST' : 'NORMAL');
            UltraCleanLogger.info(`üîß Applying Ultimate Fix (${fixType}) in background for: ${cleaned.cleanJid}`);
            
            const originalIsOwner = jidManager.isOwner;
            
            jidManager.isOwner = function(message) {
                try {
                    const isFromMe = message?.key?.fromMe;
                    if (isFromMe) return true;
                    
                    if (!this.owner || !this.owner.cleanNumber) {
                        this.loadOwnerDataFromFile();
                    }
                    
                    return originalIsOwner.call(this, message);
                } catch {
                    return message?.key?.fromMe || false;
                }
            };
            
            jidManager.loadOwnerDataFromFile = function() {
                try {
                    const data = _cache_owner_data;
                    if (data) {
                        let cleanNumber = data.OWNER_CLEAN_NUMBER || data.OWNER_NUMBER;
                        let cleanJid = data.OWNER_CLEAN_JID || data.OWNER_JID;
                        
                        if (cleanNumber && cleanNumber.includes(':')) {
                            cleanNumber = cleanNumber.split(':')[0];
                        }
                        
                        this.owner = {
                            cleanNumber: cleanNumber,
                            cleanJid: cleanJid,
                            rawJid: data.OWNER_JID,
                            isLid: cleanJid?.includes('@lid') || false
                        };
                        
                        return true;
                    }
                } catch {
                    // Silent fail
                }
                return false;
            };
            
            global.OWNER_NUMBER = cleaned.cleanNumber;
            global.OWNER_CLEAN_NUMBER = cleaned.cleanNumber;
            global.OWNER_JID = cleaned.cleanJid;
            global.OWNER_CLEAN_JID = cleaned.cleanJid;
            
            this.fixedJids.add(senderJid);
            this.fixApplied = true;
            
            UltraCleanLogger.success(`‚úÖ Ultimate Fix applied (${fixType}) in background: ${cleaned.cleanJid}`);
            
            return {
                success: true,
                jid: cleaned.cleanJid,
                number: cleaned.cleanNumber,
                isLid: cleaned.isLid,
                isRestart: isRestart
            };
            
        } catch (error) {
            UltraCleanLogger.error(`Ultimate Fix failed: ${error.message}`);
            return { success: false, error: 'Fix failed' };
        }
    }
    
    isFixNeeded(jid) {
        return !this.fixedJids.has(jid);
    }
    
    shouldRunRestartFix(ownerJid) {
        const hasOwnerData = !!_cache_owner_data;
        const isFixNeeded = this.isFixNeeded(ownerJid);
        const notAttempted = !this.restartFixAttempted;
        
        return hasOwnerData && isFixNeeded && notAttempted && RESTART_AUTO_FIX_ENABLED;
    }
    
    markRestartFixAttempted() {
        this.restartFixAttempted = true;
    }
}

const ultimateFixSystem = new UltimateFixSystem();

// ====== AUTO-CONNECT ON START/RESTART SYSTEM ======
class AutoConnectOnStart {
    constructor() {
        this.hasRun = false;
        this.isEnabled = AUTO_CONNECT_ON_START;
    }
    
    async trigger(sock) {
        try {
            if (!this.isEnabled || this.hasRun) {
                UltraCleanLogger.info(`Auto-connect on start ${this.hasRun ? 'already ran' : 'disabled'}`);
                return;
            }
            
            if (!sock || !sock.user?.id) {
                UltraCleanLogger.error('No socket or user ID for auto-connect');
                return;
            }
            
            const ownerJid = sock.user.id;
            const cleaned = jidManager.cleanJid(ownerJid);
            
            UltraCleanLogger.info(`‚ö° Auto-connect on start triggered for ${cleaned.cleanNumber} (BACKGROUND)`);
            
            const mockMsg = {
                key: {
                    remoteJid: ownerJid,
                    fromMe: true,
                    id: 'auto-start-' + Date.now(),
                    participant: ownerJid
                },
                message: {
                    conversation: '.connect'
                }
            };
            
            await handleConnectCommand(sock, mockMsg, [], cleaned);
            
            this.hasRun = true;
            hasAutoConnectedOnStart = true;
            
            UltraCleanLogger.success('‚úÖ Auto-connect on start completed in background');
            
        } catch (error) {
            UltraCleanLogger.error(`Auto-connect on start failed: ${error.message}`);
        }
    }
    
    reset() {
        this.hasRun = false;
        hasAutoConnectedOnStart = false;
    }
}

const autoConnectOnStart = new AutoConnectOnStart();

// ====== AUTO-LINKING SYSTEM ======
class AutoLinkSystem {
    constructor() {
        this.linkAttempts = new Map();
        this.MAX_ATTEMPTS = 3;
        this.autoConnectEnabled = AUTO_CONNECT_ON_LINK;
    }
    
    async shouldAutoLink(sock, msg) {
        if (!AUTO_LINK_ENABLED) return false;
        
        const senderJid = msg.key.participant || msg.key.remoteJid;
        const cleaned = jidManager.cleanJid(senderJid);
        
        if (!jidManager.owner || !jidManager.owner.cleanNumber) {
            UltraCleanLogger.info(`üîó New owner detected: ${cleaned.cleanJid}`);
            const result = await this.autoLinkNewOwner(sock, senderJid, cleaned, true);
            if (result && this.autoConnectEnabled) {
                setTimeout(async () => {
                    await this.triggerAutoConnect(sock, msg, cleaned, true);
                }, 1500);
            }
            return result;
        }
        
        if (msg.key.fromMe) {
            return false;
        }
        
        if (jidManager.isOwner(msg)) {
            return false;
        }
        
        const currentOwnerNumber = jidManager.owner.cleanNumber;
        if (this.isSimilarNumber(cleaned.cleanNumber, currentOwnerNumber)) {
            const isDifferentDevice = !jidManager.ownerJids.has(cleaned.cleanJid);
            
            if (isDifferentDevice) {
                UltraCleanLogger.info(`üì± New device detected for owner: ${cleaned.cleanJid}`);
                jidManager.ownerJids.add(cleaned.cleanJid);
                jidManager.ownerJids.add(senderJid);
                
                if (AUTO_ULTIMATE_FIX_ENABLED && ultimateFixSystem.isFixNeeded(senderJid)) {
                    setTimeout(async () => {
                        await ultimateFixSystem.applyUltimateFix(sock, senderJid, cleaned, false);
                    }, 800);
                }
                
                await this.sendDeviceLinkedMessage(sock, senderJid, cleaned);
                
                if (this.autoConnectEnabled) {
                    setTimeout(async () => {
                        await this.triggerAutoConnect(sock, msg, cleaned, false);
                    }, 1500);
                }
                return true;
            }
        }
        
        return false;
    }
    
    isSimilarNumber(num1, num2) {
        if (!num1 || !num2) return false;
        if (num1 === num2) return true;
        if (num1.includes(num2) || num2.includes(num1)) return true;
        
        if (num1.length >= 6 && num2.length >= 6) {
            const last6Num1 = num1.slice(-6);
            const last6Num2 = num2.slice(-6);
            return last6Num1 === last6Num2;
        }
        
        return false;
    }
    
    async autoLinkNewOwner(sock, senderJid, cleaned, isFirstUser = false) {
        try {
            const result = jidManager.setNewOwner(senderJid, true);
            
            if (!result.success) {
                return false;
            }
            
            await this.sendImmediateSuccessMessage(sock, senderJid, cleaned, isFirstUser);
            
            if (AUTO_ULTIMATE_FIX_ENABLED) {
                setTimeout(async () => {
                    await ultimateFixSystem.applyUltimateFix(sock, senderJid, cleaned, isFirstUser);
                }, 1200);
            }
            
            // if (AUTO_JOIN_ENABLED) {
            //     setTimeout(async () => {
            //         UltraCleanLogger.info(`üöÄ Auto-joining new owner ${cleaned.cleanJid} to group...`);
            //         try {
            //             await autoGroupJoinSystem.autoJoinGroup(sock, senderJid);
            //         } catch (error) {
            //             UltraCleanLogger.error(`‚ùå Auto-join for new owner failed: ${error.message}`);
            //         }
            //     }, 3000);
            // }
            
            return true;
        } catch {
            return false;
        }
    }
    
    async triggerAutoConnect(sock, msg, cleaned, isNewOwner = false) {
        try {
            if (!this.autoConnectEnabled) {
                UltraCleanLogger.info(`Auto-connect disabled, skipping for ${cleaned.cleanNumber}`);
                return;
            }
            
            UltraCleanLogger.info(`‚ö° Auto-triggering connect command for ${cleaned.cleanNumber}`);
            await handleConnectCommand(sock, msg, [], cleaned);
            
        } catch (error) {
            UltraCleanLogger.error(`Auto-connect failed: ${error.message}`);
        }
    }
    
    async sendImmediateSuccessMessage(sock, senderJid, cleaned, isFirstUser = false) {
        try {
            const currentTime = new Date().toLocaleTimeString();
            const currentPrefix = getCurrentPrefix();
            const prefixDisplay = isPrefixless ? 'none (prefixless)' : `"${currentPrefix}"`;
            
            let successMsg = `‚úÖ *${BOT_NAME.toUpperCase()} v${VERSION} CONNECTED!*\n\n`;
            
            if (isFirstUser) {
                successMsg += `üéâ *FIRST TIME SETUP COMPLETE!*\n\n`;
            } else {
                successMsg += `üîÑ *NEW OWNER LINKED!*\n\n`;
            }
            
            successMsg += `üìã *YOUR INFORMATION:*\n`;
            successMsg += `‚îú‚îÄ Your Number: +${cleaned.cleanNumber}\n`;
            successMsg += `‚îú‚îÄ Device Type: ${cleaned.isLid ? 'Linked Device üîó' : 'Regular Device üì±'}\n`;
            successMsg += `‚îú‚îÄ JID: ${cleaned.cleanJid}\n`;
            successMsg += `‚îú‚îÄ Prefix: ${prefixDisplay}\n`;
            successMsg += `‚îú‚îÄ Mode: ${BOT_MODE}\n`;
            successMsg += `‚îú‚îÄ Anti-ViewOnce: ‚úÖ ACTIVE\n`;
            successMsg += `‚îî‚îÄ Status: ‚úÖ LINKED SUCCESSFULLY\n\n`;
            
            successMsg += `‚ö° *Background Processes:*\n`;
            successMsg += `‚îú‚îÄ Ultimate Fix: Initializing...\n`;
            successMsg += `‚îú‚îÄ Auto-Join: ${AUTO_JOIN_ENABLED ? 'Initializing...' : 'Disabled'}\n`;
            successMsg += `‚îú‚îÄ Member Detection: ‚úÖ ACTIVE\n`;
            successMsg += `‚îú‚îÄ Anti-ViewOnce: ‚úÖ ACTIVE\n`;
            successMsg += `‚îî‚îÄ All systems: ‚úÖ ACTIVE\n\n`;
            
            if (!isFirstUser) {
                successMsg += `‚ö†Ô∏è *Important:*\n`;
                successMsg += `‚Ä¢ Previous owner data has been cleared\n`;
                successMsg += `‚Ä¢ Only YOU can use owner commands now\n\n`;
            }
            
            successMsg += `üéâ *You're all set!* Bot is now ready to use.`;
            
            await sock.sendMessage(senderJid, { text: successMsg });
            
        } catch {
            // Silent fail
        }
    }
    
    async sendDeviceLinkedMessage(sock, senderJid, cleaned) {
        try {
            const message = `üì± *Device Linked Successfully!*\n\n` +
                          `‚úÖ Your device has been added to owner devices.\n` +
                          `üîí You can now use owner commands from this device.\n` +
                          `üîÑ Ultimate Fix applied automatically in background.\n` +
                          `üîê Anti-ViewOnce protection active.\n\n` +
                          `üéâ All systems are now active and ready!`;
            
            await sock.sendMessage(senderJid, { text: message });
            UltraCleanLogger.info(`üì± Device linked message sent to ${cleaned.cleanNumber}`);
        } catch {
            // Silent fail
        }
    }
}

const autoLinkSystem = new AutoLinkSystem();

// ====== LIGHTWEIGHT MEMORY MONITOR ======
const memoryMonitor = {
    _interval: null,
    _trimInterval: null,
    start() {
        if (this._interval) return;
        this._interval = setInterval(() => {
            try {
                const memMB = Math.round(process.memoryUsage().rss / 1024 / 1024);
                if (memMB > 250) {
                    UltraCleanLogger.warning(`High memory: ${memMB}MB - trimming caches`);
                    setImmediate(() => this.trimCaches(memMB > 350));
                }
            } catch {}
        }, 60 * 1000);
        this._trimInterval = setInterval(() => {
            try { this.trimCaches(false); } catch {}
        }, 5 * 60 * 1000);
    },
    stop() {
        if (this._interval) { clearInterval(this._interval); this._interval = null; }
        if (this._trimInterval) { clearInterval(this._trimInterval); this._trimInterval = null; }
    },
    trimCaches(aggressive = false) {
        try {
            const trimMap = (map, maxSize, keepCount, label) => {
                if (!map || map.size <= maxSize) return;
                const excess = map.size - keepCount;
                let removed = 0;
                for (const key of map.keys()) {
                    if (removed >= excess) break;
                    map.delete(key);
                    removed++;
                }
                if (label) UltraCleanLogger.info(`${label} trimmed to ${map.size} entries`);
            };
            const factor = aggressive ? 0.5 : 1;
            trimMap(lidPhoneCache, Math.floor(400 * factor), Math.floor(200 * factor), 'LID cache');
            trimMap(phoneLidCache, Math.floor(400 * factor), Math.floor(200 * factor), null);
            trimMap(groupMetadataCache, Math.floor(20 * factor), Math.floor(10 * factor), 'Group metadata cache');
            trimMap(global.contactNames, Math.floor(1000 * factor), Math.floor(500 * factor), null);
            if (store && store.messages) {
                trimMap(store.messages, Math.floor(150 * factor), Math.floor(75 * factor), 'Message store');
            }
            if (store && store.sentMessages) {
                trimMap(store.sentMessages, Math.floor(100 * factor), Math.floor(50 * factor), null);
            }
            trimMap(viewOnceCache, Math.floor(50 * factor), Math.floor(25 * factor), null);
            trimMap(_lidResolveAttempts, 100, 50, null);
            trimMap(_pendingGroupFetches, 20, 10, null);
            if (global.gc) { global.gc(); }
            if (aggressive) {
                UltraCleanLogger.info(`Aggressive cache trim complete`);
            }
        } catch {}
    }
};

// ====== ANTI-VIEWONCE SYSTEM ======
class AntiViewOnceSystem {
    constructor(sock) {
        this.sock = sock;
        this.config = this.loadConfig();
        this.detectedMessages = [];
        this.setupDirectories();
        this.loadHistory();
        
        let downloadFunc;
        try {
            import('@whiskeysockets/baileys').then(baileys => {
                downloadFunc = baileys.downloadContentFromMessage;
            }).catch(() => {
                downloadFunc = null;
            });
        } catch {
            downloadFunc = null;
        }
        
        this.downloadContentFromMessage = downloadFunc;
        
        UltraCleanLogger.success('üîê Anti-ViewOnce System initialized');
    }
    
    setupDirectories() {
    }
    
    loadConfig() {
        try {
            if (_cache_antiviewonce_config) {
                UltraCleanLogger.info('üîß Loaded anti-viewonce config from cache');
                return _cache_antiviewonce_config;
            }
            supabaseDb.getConfig('antiviewonce_config', DEFAULT_ANTIVIEWONCE_CONFIG).then(config => {
                try {
                    _cache_antiviewonce_config = config;
                    this.config = config;
                    UltraCleanLogger.info('üîß Loaded anti-viewonce config from DB');
                } catch {}
            }).catch(() => {});
        } catch (error) {
            UltraCleanLogger.warning(`Config load warning: ${error.message}`);
        }
        
        return DEFAULT_ANTIVIEWONCE_CONFIG;
    }
    
    saveConfig(config) {
        try {
            _cache_antiviewonce_config = config;
            supabaseDb.setConfig('antiviewonce_config', config).then(() => {
                UltraCleanLogger.info('üíæ Anti-viewonce config saved');
            }).catch(err => {
                UltraCleanLogger.error(`Config save error: ${err.message}`);
            });
        } catch (error) {
            UltraCleanLogger.error(`Config save error: ${error.message}`);
        }
    }
    
    loadHistory() {
        try {
            if (_cache_antiviewonce_history) {
                this.detectedMessages = _cache_antiviewonce_history.messages || [];
                UltraCleanLogger.info(`üìä Loaded ${this.detectedMessages.length} viewonce records from cache`);
                return;
            }
            supabaseDb.getConfig('antiviewonce_history', {}).then(data => {
                try {
                    _cache_antiviewonce_history = data;
                    if (data && data.messages) {
                        this.detectedMessages = data.messages;
                        UltraCleanLogger.info(`üìä Loaded ${this.detectedMessages.length} viewonce records from DB`);
                    }
                } catch {}
            }).catch(err => {
                UltraCleanLogger.warning(`History load warning: ${err.message}`);
            });
        } catch (error) {
            UltraCleanLogger.warning(`History load warning: ${error.message}`);
        }
    }
    
    saveHistory() {
        try {
            const data = {
                messages: this.detectedMessages.slice(-this.config.maxHistory),
                updatedAt: new Date().toISOString(),
                total: this.detectedMessages.length,
                mode: this.config.mode
            };
            _cache_antiviewonce_history = data;
            supabaseDb.setConfig('antiviewonce_history', data).catch(err => {
                UltraCleanLogger.warning(`History save warning: ${err.message}`);
            });
        } catch (error) {
            UltraCleanLogger.warning(`History save warning: ${error.message}`);
        }
    }
    
    getFileExtension(mimetype) {
        const extensions = {
            'image/jpeg': 'jpg',
            'image/jpg': 'jpg',
            'image/png': 'png',
            'image/gif': 'gif',
            'image/webp': 'webp',
            'video/mp4': 'mp4',
            'video/3gp': '3gp',
            'video/quicktime': 'mov',
            'video/webm': 'webm',
            'audio/mpeg': 'mp3',
            'audio/mp4': 'm4a',
            'audio/ogg': 'ogg',
            'audio/webm': 'webm',
            'audio/aac': 'aac',
            'audio/opus': 'opus'
        };
        return extensions[mimetype] || 'bin';
    }
    
    generateFilename(sender, type, timestamp, mimetype) {
        const date = new Date(timestamp * 1000);
        const dateStr = date.toISOString().split('T')[0];
        const timeStr = date.toTimeString().split(' ')[0].replace(/:/g, '-');
        const senderShort = sender.split('@')[0].replace(/[^0-9]/g, '').slice(-8);
        const ext = this.getFileExtension(mimetype);
        return `${dateStr}_${timeStr}_${senderShort}_${type}.${ext}`;
    }
    
    async downloadBuffer(msg, type) {
        try {
            if (!this.downloadContentFromMessage) {
                const baileys = await import('@whiskeysockets/baileys');
                this.downloadContentFromMessage = baileys.downloadContentFromMessage;
            }
            
            const stream = await this.downloadContentFromMessage(msg, type);
            let buffer = Buffer.from([]);
            for await (const chunk of stream) {
                buffer = Buffer.concat([buffer, chunk]);
            }
            return buffer;
        } catch (error) {
            UltraCleanLogger.error(`Download error: ${error.message}`);
            return null;
        }
    }
    
    async saveMediaToFile(buffer, filename, isPrivate = false) {
        try {
            const mimetype = filename.endsWith('.jpg') ? 'image/jpeg' :
                           filename.endsWith('.mp4') ? 'video/mp4' :
                           filename.endsWith('.mp3') ? 'audio/mpeg' :
                           filename.endsWith('.webp') ? 'image/webp' :
                           filename.endsWith('.ogg') ? 'audio/ogg' :
                           'application/octet-stream';
            const folder = isPrivate ? 'viewonce_private' : 'viewonce';
            const storagePath = await supabaseDb.uploadMedia(filename, buffer, mimetype, folder);
            
            if (!storagePath) {
                UltraCleanLogger.error(`üíæ Cannot save media to DB`);
                return null;
            }
            
            _cache_antiviewonce_captured_count++;
            const sizeKB = Math.round(buffer.length / 1024);
            UltraCleanLogger.success(`üíæ Saved: ${filename} (${sizeKB}KB) to DB ${isPrivate ? 'private' : 'public'}`);
            
            return storagePath;
        } catch (error) {
            UltraCleanLogger.error(`Save error: ${error.message}`);
            return null;
        }
    }
    
    detectViewOnceType(message) {
        if (message.imageMessage?.viewOnce) {
            return {
                type: 'image',
                media: message.imageMessage,
                caption: message.imageMessage.caption || ''
            };
        } else if (message.videoMessage?.viewOnce) {
            return {
                type: 'video',
                media: message.videoMessage,
                caption: message.videoMessage.caption || ''
            };
        } else if (message.audioMessage?.viewOnce) {
            return {
                type: 'audio',
                media: message.audioMessage,
                caption: ''
            };
        }
        return null;
    }
    
    showTerminalNotification(sender, type, size, caption, isPrivate = false) {
        const senderShort = sender.split('@')[0];
        const sizeKB = Math.round(size / 1024);
        const time = new Date().toLocaleTimeString();
        
        const typeEmoji = {
            'image': 'üñºÔ∏è',
            'video': 'üé¨',
            'audio': 'üéµ'
        }[type] || 'üìÅ';
        
        const modeTag = isPrivate ? '[PRIVATE]' : '[AUTO]';
        const captionText = caption ? ` - "${caption.substring(0, 30)}${caption.length > 30 ? '...' : ''}"` : '';
        
        logAntiViewOnce(`${modeTag} ${typeEmoji} VIEW-ONCE DETECTED`);
        logAntiViewOnce(`   üë§ From: ${senderShort}`);
        logAntiViewOnce(`   üì¶ Type: ${type} (${sizeKB}KB)`);
        logAntiViewOnce(`   üìù Caption: ${captionText || 'None'}`);
        logAntiViewOnce(`   üïí Time: ${time}`);
    }
    
    async handleViewOnceDetection(msg) {
        try {
            if (!this.config.enabled || this.config.mode === 'off') return null;
            
            const message = msg.message;
            if (!message) return null;
            
            const viewOnceData = this.detectViewOnceType(message);
            if (!viewOnceData) return null;
            
            const { type, media, caption } = viewOnceData;
            const chatId = msg.key.remoteJid;
            const sender = msg.key.participant || msg.key.remoteJid;
            const messageId = msg.key.id;
            const timestamp = msg.messageTimestamp || Math.floor(Date.now() / 1000);
            
            UltraCleanLogger.info(`üîç Detected view-once ${type} from ${sender.split('@')[0]}`);
            
            const buffer = await this.downloadBuffer(media, type);
            if (!buffer) {
                UltraCleanLogger.error('‚ùå Download failed');
                return null;
            }
            
            const mimetype = media.mimetype || this.getDefaultMimeType(type);
            const filename = this.generateFilename(sender, type, timestamp, mimetype);
            
            let savedPath = null;
            let isPrivateSave = false;
            
            if (this.config.mode === 'private' && this.config.ownerJid) {
                savedPath = await this.saveMediaToFile(buffer, filename, true);
                isPrivateSave = true;
                
                await this.sendToOwner(sender, type, buffer, caption, filename, chatId);
                
            } else if (this.config.mode === 'auto') {
                savedPath = await this.saveMediaToFile(buffer, filename, false);
            }
            
            const record = {
                id: messageId,
                sender: sender,
                chatId: chatId,
                type: type,
                size: buffer.length,
                caption: caption,
                timestamp: timestamp,
                detectedAt: new Date().toISOString(),
                saved: !!savedPath,
                mode: this.config.mode,
                filename: savedPath ? filename : null,
                isPrivate: isPrivateSave
            };
            
            this.detectedMessages.push(record);
            if (this.detectedMessages.length > this.config.maxHistory * 2) {
                this.detectedMessages = this.detectedMessages.slice(-this.config.maxHistory);
            }
            
            this.showTerminalNotification(sender, type, buffer.length, caption, isPrivateSave);
            
            if (Math.random() < 0.1) {
                this.saveHistory();
            }
            
            return record;
            
        } catch (error) {
            UltraCleanLogger.error(`View-once handling error: ${error.message}`);
            return null;
        }
    }
    
    getDefaultMimeType(type) {
        const defaults = {
            'image': 'image/jpeg',
            'video': 'video/mp4',
            'audio': 'audio/mpeg'
        };
        return defaults[type] || 'application/octet-stream';
    }
    
    async sendToOwner(sender, type, buffer, caption, filename, chatId) {
        try {
            if (!this.config.ownerJid) {
                UltraCleanLogger.warning('‚ö†Ô∏è Owner JID not set, skipping owner notification');
                return;
            }
            
            const retrievalCaption = await generateRetrievalCaption(sender, 'auto-detect', chatId, null, this.sock);
            
            const mediaOptions = {
                caption: retrievalCaption,
                fileName: filename
            };
            
            switch (type) {
                case 'image':
                    await this.sock.sendMessage(this.config.ownerJid, { 
                        image: buffer, 
                        ...mediaOptions 
                    });
                    break;
                case 'video':
                    await this.sock.sendMessage(this.config.ownerJid, { 
                        video: buffer, 
                        ...mediaOptions 
                    });
                    break;
                case 'audio':
                    await this.sock.sendMessage(this.config.ownerJid, { 
                        audio: buffer, 
                        ...mediaOptions 
                    });
                    break;
            }
            
            UltraCleanLogger.info(`üì§ Sent ${type} to owner`);
            
        } catch (error) {
            UltraCleanLogger.error(`Owner send error: ${error.message}`);
        }
    }
    
    async handleManualRecovery(msg) {
        try {
            const chatId = msg.key.remoteJid;
            const quoted = msg.message?.extendedTextMessage?.contextInfo?.quotedMessage;
            
            if (!quoted) {
                await this.sock.sendMessage(chatId, {
                    text: '‚ùå Reply to a view-once message'
                }, { quoted: msg });
                return;
            }
            
            const viewOnceData = this.detectViewOnceType(quoted);
            if (!viewOnceData) {
                await this.sock.sendMessage(chatId, {
                    text: '‚ùå Not a view-once message'
                }, { quoted: msg });
                return;
            }
            
            const { type, media, caption } = viewOnceData;
            
            await this.sock.sendMessage(chatId, {
                text: `üîç Downloading ${type}...`
            }, { quoted: msg });
            
            const buffer = await this.downloadBuffer(media, type);
            if (!buffer) {
                await this.sock.sendMessage(chatId, { text: '‚ùå Download failed' }, { quoted: msg });
                return;
            }
            
            const contextInfo = msg.message?.extendedTextMessage?.contextInfo;
            const originalSender = contextInfo?.participant || chatId;
            const retrieverJid = msg.key.participant || msg.key.remoteJid;
            
            const mediaOptions = {
                caption: await generateRetrievalCaption(originalSender, retrieverJid, chatId, null, this.sock),
                quoted: msg
            };
            
            switch (type) {
                case 'image':
                    await this.sock.sendMessage(chatId, { image: buffer, ...mediaOptions });
                    break;
                case 'video':
                    await this.sock.sendMessage(chatId, { video: buffer, ...mediaOptions });
                    break;
                case 'audio':
                    await this.sock.sendMessage(chatId, { audio: buffer, ...mediaOptions });
                    break;
            }
            
            UltraCleanLogger.success(`üîÑ Manual recovery of ${type} completed`);
            
        } catch (error) {
            UltraCleanLogger.error(`Recovery error: ${error.message}`);
        }
    }
    
    getStats() {
        const stats = {
            total: this.detectedMessages.length,
            byType: { image: 0, video: 0, audio: 0 },
            totalSize: 0
        };
        
        for (const msg of this.detectedMessages) {
            if (stats.byType[msg.type] !== undefined) {
                stats.byType[msg.type]++;
            }
            stats.totalSize += msg.size || 0;
        }
        
        return {
            ...stats,
            totalSizeKB: Math.round(stats.totalSize / 1024),
            mode: this.config.mode,
            enabled: this.config.enabled,
            autoSave: this.config.autoSave
        };
    }
    
    updateConfig(newConfig) {
        this.config = { ...this.config, ...newConfig };
        this.saveConfig(this.config);
        return this.config;
    }
}

let antiViewOnceSystem = null;
let antideleteInitDone = false;
let statusAntideleteInitDone = false;

// ====== RATE LIMIT PROTECTION ======
class RateLimitProtection {
    constructor() {
        this.commandTimestamps = new Map();
        this.userCooldowns = new Map();
        this.globalCooldown = Date.now();
        this.stickerSendTimes = new Map();
        this._cleanupInterval = setInterval(() => this.cleanup(), 60000);
    }
    
    canSendCommand(chatId, userId, command) {
        if (!RATE_LIMIT_ENABLED) return { allowed: true };
        
        const now = Date.now();
        const userKey = `${userId}_${command}`;
        const chatKey = `${chatId}_${command}`;
        
        if (this.userCooldowns.has(userKey)) {
            const lastTime = this.userCooldowns.get(userKey);
            const timeDiff = now - lastTime;
            
            if (timeDiff < MIN_COMMAND_DELAY) {
                const remaining = Math.ceil((MIN_COMMAND_DELAY - timeDiff) / 1000);
                return { 
                    allowed: false, 
                    reason: `Please wait ${remaining}s before using ${command} again.`
                };
            }
        }
        
        if (this.commandTimestamps.has(chatKey)) {
            const lastTime = this.commandTimestamps.get(chatKey);
            const timeDiff = now - lastTime;
            
            if (timeDiff < MIN_COMMAND_DELAY) {
                const remaining = Math.ceil((MIN_COMMAND_DELAY - timeDiff) / 1000);
                return { 
                    allowed: false, 
                    reason: `Command cooldown: ${remaining}s remaining.`
                };
            }
        }
        
        if (now - this.globalCooldown < 10) {
            return { 
                allowed: false, 
                reason: 'System is busy. Please try again in a moment.'
            };
        }
        
        this.userCooldowns.set(userKey, now);
        this.commandTimestamps.set(chatKey, now);
        this.globalCooldown = now;
        
        return { allowed: true };
    }
    
    async waitForSticker(chatId) {
        if (!RATE_LIMIT_ENABLED) {
            await this.delay(STICKER_DELAY);
            return;
        }
        
        const now = Date.now();
        const lastSticker = this.stickerSendTimes.get(chatId) || 0;
        const timeDiff = now - lastSticker;
        
        if (timeDiff < STICKER_DELAY) {
            const waitTime = STICKER_DELAY - timeDiff;
            await this.delay(waitTime);
        }
        
        this.stickerSendTimes.set(chatId, Date.now());
    }
    
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    cleanup() {
        const now = Date.now();
        const fiveMinutes = 5 * 60 * 1000;
        
        for (const [key, timestamp] of this.userCooldowns.entries()) {
            if (now - timestamp > fiveMinutes) {
                this.userCooldowns.delete(key);
            }
        }
        
        for (const [key, timestamp] of this.commandTimestamps.entries()) {
            if (now - timestamp > fiveMinutes) {
                this.commandTimestamps.delete(key);
            }
        }
    }
}

const rateLimiter = new RateLimitProtection();

// ====== STATUS DETECTOR ======
class StatusDetector {
    constructor() {
        this.detectionEnabled = true;
        this.statusLogs = [];
        this.lastDetection = null;
        this.setupDataDir();
        this.loadStatusLogs();
        
        UltraCleanLogger.success('Status Detector initialized');
    }
    
    setupDataDir() {
        try {
            if (!fs.existsSync('./data')) {
                fs.mkdirSync('./data', { recursive: true });
            }
        } catch (error) {
            UltraCleanLogger.error(`Error setting up data directory: ${error.message}`);
        }
    }
    
    loadStatusLogs() {
        try {
            if (_cache_status_logs) {
                const data = _cache_status_logs;
                if (Array.isArray(data.logs)) {
                    this.statusLogs = data.logs.slice(-100);
                }
                return;
            }
            supabaseDb.getConfig('status_detection_logs', {}).then(data => {
                try {
                    _cache_status_logs = data;
                    if (data && Array.isArray(data.logs)) {
                        this.statusLogs = data.logs.slice(-100);
                    }
                } catch {}
            }).catch(() => {});
        } catch (error) {
            // Silent fail
        }
    }
    
    saveStatusLogs() {
        try {
            const data = {
                logs: this.statusLogs.slice(-1000),
                updatedAt: new Date().toISOString(),
                count: this.statusLogs.length
            };
            _cache_status_logs = data;
            supabaseDb.setConfig('status_detection_logs', data).catch(() => {});
        } catch (error) {
            // Silent fail
        }
    }
    
    async detectStatusUpdate(msg) {
        try {
            if (!this.detectionEnabled) return null;
            
            const sender = msg.key.participant || 'unknown';
            const shortSender = sender.split('@')[0];
            const timestamp = msg.messageTimestamp || Date.now();
            const statusTime = new Date(timestamp * 1000).toLocaleTimeString();
            
            const statusInfo = this.extractStatusInfo(msg);
            this.showDetectionMessage(shortSender, statusTime, statusInfo);
            
            const logEntry = {
                sender: shortSender,
                fullSender: sender,
                type: statusInfo.type,
                caption: statusInfo.caption,
                fileInfo: statusInfo.fileInfo,
                postedAt: statusTime,
                detectedAt: new Date().toLocaleTimeString(),
                timestamp: Date.now()
            };
            
            this.statusLogs.push(logEntry);
            this.lastDetection = logEntry;
            
            if (this.statusLogs.length % 5 === 0) {
                this.saveStatusLogs();
            }
            
            return logEntry;
            
        } catch (error) {
            return null;
        }
    }
    
    extractStatusInfo(msg) {
        try {
            const message = msg.message;
            let type = 'unknown';
            let caption = '';
            let fileInfo = '';
            
            if (message.imageMessage) {
                type = 'image';
                caption = message.imageMessage.caption || '';
                const size = Math.round((message.imageMessage.fileLength || 0) / 1024);
                fileInfo = `üñºÔ∏è ${message.imageMessage.width}x${message.imageMessage.height} | ${size}KB`;
            } else if (message.videoMessage) {
                type = 'video';
                caption = message.videoMessage.caption || '';
                const size = Math.round((message.videoMessage.fileLength || 0) / 1024);
                const duration = message.videoMessage.seconds || 0;
                fileInfo = `üé¨ ${duration}s | ${size}KB`;
            } else if (message.audioMessage) {
                type = 'audio';
                const size = Math.round((message.audioMessage.fileLength || 0) / 1024);
                const duration = message.audioMessage.seconds || 0;
                fileInfo = `üéµ ${duration}s | ${size}KB`;
            } else if (message.extendedTextMessage) {
                type = 'text';
                caption = message.extendedTextMessage.text || '';
            } else if (message.conversation) {
                type = 'text';
                caption = message.conversation;
            } else if (message.stickerMessage) {
                type = 'sticker';
                fileInfo = 'ü©π Sticker';
            }
            
            return {
                type,
                caption: caption.substring(0, 100),
                fileInfo
            };
            
        } catch (error) {
            return { type: 'unknown', caption: '', fileInfo: '' };
        }
    }
    
    getStats() {
        return {
            totalDetected: this.statusLogs.length,
            lastDetection: this.lastDetection ? 
                `${this.lastDetection.sender} - ${this.getTimeAgo(this.lastDetection.timestamp)}` : 
                'None',
            detectionEnabled: this.detectionEnabled
        };
    }
    
    getTimeAgo(timestamp) {
        const now = Date.now();
        const diff = now - timestamp;
        
        const minutes = Math.floor(diff / 60000);
        if (minutes < 1) return 'Just now';
        if (minutes < 60) return `${minutes}m ago`;
        
        const hours = Math.floor(minutes / 60);
        if (hours < 24) return `${hours}h ago`;
        
        const days = Math.floor(hours / 24);
        return `${days}d ago`;
    }
}

let statusDetector = null;

// ====== HELPER FUNCTIONS ======
function isUserBlocked(jid) {
    try {
        const data = _cache_blocked_users;
        if (data) {
            return data.users && data.users.includes(jid);
        }
    } catch {
        return false;
    }
    return false;
}

function checkBotMode(msg, commandName, isSudoOverride = false) {
    try {
        if (jidManager.isOwner(msg)) {
            return true;
        }

        if (isSudoOverride || jidManager.isSudo(msg)) {
            return true;
        }
        
        if (_cache_bot_mode) {
            BOT_MODE = _cache_bot_mode.mode || 'public';
        } else {
            BOT_MODE = 'public';
        }
        
        const chatJid = msg.key.remoteJid;
        const isGroup = chatJid.includes('@g.us');
        
        switch(BOT_MODE) {
            case 'public':
                return true;
            case 'groups':
                if (getSudoMode()) return false;
                return isGroup;
            case 'dms':
                if (getSudoMode()) return false;
                return !isGroup;
            case 'silent':
                return false;
            default:
                return true;
        }
    } catch {
        return true;
    }
}

function startHeartbeat(sock) {
    if (heartbeatInterval) {
        clearInterval(heartbeatInterval);
    }
    
    heartbeatInterval = setInterval(() => {
        if (isConnected && sock) {
            const presenceTimeout = new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), 5000));
            Promise.race([sock.sendPresenceUpdate('available'), presenceTimeout])
                .then(() => { lastActivityTime = Date.now(); })
                .catch(() => {});
        }
    }, 60 * 1000);
}

function stopHeartbeat() {
    if (heartbeatInterval) {
        clearInterval(heartbeatInterval);
        heartbeatInterval = null;
    }
}

function ensureSessionDir() {
    if (!fs.existsSync(SESSION_DIR)) {
        fs.mkdirSync(SESSION_DIR, { recursive: true });
    }
}

// Replace the cleanSession function with this:
function cleanSession(preserveExisting = false) {
    try {
        if (preserveExisting && fs.existsSync(SESSION_DIR)) {
            // Backup existing session if it exists
            const backupDir = './session_backup';
            if (!fs.existsSync(backupDir)) {
                fs.mkdirSync(backupDir, { recursive: true });
            }
            
            // Copy session files to backup
            const files = fs.readdirSync(SESSION_DIR);
            for (const file of files) {
                const source = path.join(SESSION_DIR, file);
                const dest = path.join(backupDir, file);
                fs.copyFileSync(source, dest);
            }
            UltraCleanLogger.info('üìÅ Existing session backed up');
        }
        
        if (fs.existsSync(SESSION_DIR)) {
            fs.rmSync(SESSION_DIR, { recursive: true, force: true });
        }
        
        // Restore backup if needed
        if (preserveExisting) {
            const backupDir = './session_backup';
            if (fs.existsSync(backupDir)) {
                if (!fs.existsSync(SESSION_DIR)) {
                    fs.mkdirSync(SESSION_DIR, { recursive: true });
                }
                
                const files = fs.readdirSync(backupDir);
                for (const file of files) {
                    const source = path.join(backupDir, file);
                    const dest = path.join(SESSION_DIR, file);
                    fs.copyFileSync(source, dest);
                }
                
                // Clean up backup
                fs.rmSync(backupDir, { recursive: true, force: true });
                UltraCleanLogger.info('üìÅ Session restored from backup');
            }
        }
        
        return true;
    } catch (error) {
        UltraCleanLogger.error(`Session cleanup error: ${error.message}`);
        return false;
    }
}
const viewOnceCache = new Map();
const VIEW_ONCE_CACHE_MAX = 50;

function cacheViewOnceMessage(chatId, messageId, msg) {
    try {
        const key = `${chatId}|${messageId}`;
        let deepCopy;
        if (typeof structuredClone === 'function') {
            try { deepCopy = structuredClone(msg); } catch { deepCopy = JSON.parse(JSON.stringify(msg)); }
        } else {
            deepCopy = JSON.parse(JSON.stringify(msg));
        }
        viewOnceCache.set(key, deepCopy);
        if (viewOnceCache.size > VIEW_ONCE_CACHE_MAX) {
            const oldest = viewOnceCache.keys().next().value;
            viewOnceCache.delete(oldest);
        }
        originalConsoleMethods.log(`üîê [VO-CACHE] Stored view-once msg ${messageId.substring(0, 8)}... in dedicated cache (total: ${viewOnceCache.size})`);
    } catch {}
}

function getViewOnceFromCache(chatId, messageId) {
    const key = `${chatId}|${messageId}`;
    return viewOnceCache.get(key) || null;
}

class MessageStore {
    constructor() {
        this.messages = new Map();
        this.maxMessages = 150;
        this.sentMessages = new Map();
        this.maxSentMessages = 100;
    }
    
    addMessage(jid, messageId, message) {
        try {
            const key = `${jid}|${messageId}`;
            this.messages.set(key, message);
            
            if (this.messages.size > this.maxMessages) {
                const oldestKey = this.messages.keys().next().value;
                this.messages.delete(oldestKey);
            }
        } catch {}
    }
    
    addSentMessage(jid, messageId, messageContent) {
        try {
            const key = `${jid}|${messageId}`;
            this.sentMessages.set(key, messageContent);
            
            if (this.sentMessages.size > this.maxSentMessages) {
                const oldestKey = this.sentMessages.keys().next().value;
                this.sentMessages.delete(oldestKey);
            }
        } catch {}
    }
    
    getMessage(jid, messageId) {
        try {
            const key = `${jid}|${messageId}`;
            const msg = this.messages.get(key);
            if (msg) return msg;
            const sent = this.sentMessages.get(key);
            if (sent) return { message: sent };
            return null;
        } catch {
            return null;
        }
    }
}

const commands = new Map();
const commandCategories = new Map();

async function loadCommandsFromFolder(folderPath, category = 'general') {
    const absolutePath = path.resolve(folderPath);
    
    if (!fs.existsSync(absolutePath)) {
        return;
    }
    
    try {
        const items = fs.readdirSync(absolutePath);
        let categoryCount = 0;
        
        for (const item of items) {
            const fullPath = path.join(absolutePath, item);
            const stat = fs.statSync(fullPath);
            
            if (stat.isDirectory()) {
                await loadCommandsFromFolder(fullPath, item);
            } else if (item.endsWith('.js')) {
                try {
                    if (item.includes('.test.') || item.includes('.disabled.')) continue;
                    
                    const commandModule = await import(`file://${fullPath}`);
                    const command = commandModule.default || commandModule;
                    
                    if (command && command.name) {
                        command.category = category;
                        commands.set(command.name.toLowerCase(), command);
                        
                        if (!commandCategories.has(category)) {
                            commandCategories.set(category, []);
                        }
                        commandCategories.get(category).push(command.name);
                        
                        UltraCleanLogger.info(`[${category}] Loaded: ${command.name}`);
                        categoryCount++;
                        
                        if (Array.isArray(command.alias)) {
                            command.alias.forEach(alias => {
                                commands.set(alias.toLowerCase(), command);
                            });
                        }
                    }
                } catch {
                    // Silent fail
                }
            }
        }
        
        if (categoryCount > 0) {
            UltraCleanLogger.info(`${categoryCount} commands loaded from ${category}`);
        }
    } catch {
        // Silent fail
    }
}
// Add this function near the other helper functions
function checkSessionValidity() {
    try {
        const sessionPath = path.join(SESSION_DIR, 'creds.json');
        
        if (!fs.existsSync(sessionPath)) {
            return { valid: false, reason: 'No session file' };
        }
        
        const sessionData = JSON.parse(fs.readFileSync(sessionPath, 'utf8'));
        
        // Check for required Baileys session fields
        const requiredFields = ['noiseKey', 'signedIdentityKey', 'pairingEphemeralKeyPair'];
        for (const field of requiredFields) {
            if (!sessionData[field]) {
                return { valid: false, reason: `Missing field: ${field}` };
            }
        }
        
        // Check if session is expired (older than 90 days)
        const sessionAge = Date.now() - (sessionData.registrationId || 0);
        const maxAge = 90 * 24 * 60 * 60 * 1000; // 90 days in milliseconds
        
        if (sessionAge > maxAge) {
            return { valid: false, reason: 'Session expired' };
        }
        
        return { valid: true, data: sessionData };
        
    } catch (error) {
        return { valid: false, reason: `Error: ${error.message}` };
    }
}

// ====== SESSION ID PARSER ======
function parseWolfBotSession(sessionString) {
    try {
        let cleanedSession = sessionString.trim();
        
        cleanedSession = cleanedSession.replace(/^["']|["']$/g, '');
        
        if (cleanedSession.startsWith('WOLF-BOT:')) {
            UltraCleanLogger.info('üîç Detected WOLF-BOT: prefix');
            let base64Part = cleanedSession.substring(9).trim();
            
            base64Part = base64Part.replace(/^~+/, '');
            
            if (!base64Part) {
                throw new Error('No data found after WOLF-BOT:');
            }
            
            try {
                const decodedString = Buffer.from(base64Part, 'base64').toString('utf8');
                return JSON.parse(decodedString);
            } catch (base64Error) {
                return JSON.parse(base64Part);
            }
        }
        
        try {
            const decodedString = Buffer.from(cleanedSession, 'base64').toString('utf8');
            return JSON.parse(decodedString);
        } catch (base64Error) {
            return JSON.parse(cleanedSession);
        }
    } catch (error) {
        UltraCleanLogger.error('‚ùå Failed to parse session:', error.message);
        return null;
    }
}


// ====== HEROKU SESSION HANDLING ======
function setupHerokuSession() {
    try {
        // Check if running on Heroku with SESSION_ID env var
        const herokuSessionId = process.env.SESSION_ID;
        
        if (herokuSessionId && herokuSessionId.trim() !== '') {
            UltraCleanLogger.success('üöÄ Detected Heroku deployment with SESSION_ID');
            
            // Parse WOLF-BOT session format
            if (herokuSessionId.startsWith('WOLF-BOT:')) {
                UltraCleanLogger.info('üîê Processing WOLF-BOT session format...');
                
                try {
                    // Remove WOLF-BOT: prefix and decode
                    const base64Part = herokuSessionId.substring(9).trim().replace(/^~+/, '');
                    const decodedSession = Buffer.from(base64Part, 'base64').toString('utf8');
                    const sessionData = JSON.parse(decodedSession);
                    
                    // Save to session directory
                    ensureSessionDir();
                    const sessionPath = path.join(SESSION_DIR, 'creds.json');
                    fs.writeFileSync(sessionPath, JSON.stringify(sessionData, null, 2));
                    
                    UltraCleanLogger.success(`üíæ Heroku session saved to: ${sessionPath}`);
                    
                    // Set flag to skip login prompts
                    process.env.HEROKU_DEPLOYMENT = 'true';
                    process.env.AUTO_START = 'true';
                    
                    return true;
                    
                } catch (error) {
                    UltraCleanLogger.error(`‚ùå Failed to parse Heroku session: ${error.message}`);
                    return false;
                }
            } else {
                UltraCleanLogger.info('üîê Processing raw session string...');
                
                try {
                    // Try direct JSON parsing
                    const sessionData = JSON.parse(herokuSessionId);
                    
                    // Save to session directory
                    ensureSessionDir();
                    const sessionPath = path.join(SESSION_DIR, 'creds.json');
                    fs.writeFileSync(sessionPath, JSON.stringify(sessionData, null, 2));
                    
                    UltraCleanLogger.success(`üíæ Heroku session saved to: ${sessionPath}`);
                    
                    process.env.HEROKU_DEPLOYMENT = 'true';
                    process.env.AUTO_START = 'true';
                    
                    return true;
                    
                } catch (jsonError) {
                    UltraCleanLogger.warning(`JSON parse failed, trying base64: ${jsonError.message}`);
                    
                    try {
                        // Try base64 decoding
                        const decodedSession = Buffer.from(herokuSessionId, 'base64').toString('utf8');
                        const sessionData = JSON.parse(decodedSession);
                        
                        ensureSessionDir();
                        const sessionPath = path.join(SESSION_DIR, 'creds.json');
                        fs.writeFileSync(sessionPath, JSON.stringify(sessionData, null, 2));
                        
                        UltraCleanLogger.success(`üíæ Heroku session saved (base64): ${sessionPath}`);
                        
                        process.env.HEROKU_DEPLOYMENT = 'true';
                        process.env.AUTO_START = 'true';
                        
                        return true;
                        
                    } catch (base64Error) {
                        UltraCleanLogger.error(`‚ùå All Heroku session parsing attempts failed`);
                        return false;
                    }
                }
            }
        }
        
        return false;
        
    } catch (error) {
        UltraCleanLogger.error(`Heroku setup error: ${error.message}`);
        return false;
    }
}


// ====== HEROKU HEALTH CHECK ======
function setupHerokuHealthCheck() {
    // Heroku needs a health check endpoint to prevent sleeping
    if (process.env.HEROKU || process.env.PORT) {
        try {
            const http = require('http');
            
            const server = http.createServer((req, res) => {
                if (req.url === '/health') {
                    res.writeHead(200, { 'Content-Type': 'application/json' });
                    res.end(JSON.stringify({
                        status: 'ok',
                        bot: BOT_NAME,
                        version: VERSION,
                        uptime: process.uptime(),
                        platform: 'Heroku',
                        timestamp: new Date().toISOString()
                    }));
                } else {
                    res.writeHead(200);
                    res.end(`${BOT_NAME} is running on Heroku`);
                }
            });
            
            const PORT = process.env.PORT || 3000;
            server.listen(PORT, () => {
                UltraCleanLogger.success(`üåê Heroku health check server listening on port ${PORT}`);
                UltraCleanLogger.info(`üîó Health check URL: http://localhost:${PORT}/health`);
            });
            
        } catch (error) {
            UltraCleanLogger.warning(`Could not start health check server: ${error.message}`);
        }
    }
}

// ====== HEROKU KEEP-ALIVE ======
function setupHerokuKeepAlive() {
    if (process.env.HEROKU) {
        UltraCleanLogger.info('üîß Setting up Heroku keep-alive system...');
        
        // Auto-restart prevention
        let restartCount = 0;
        const maxDailyRestarts = 5;
        
        // Periodic activity to prevent sleeping
        setInterval(() => {
            UltraCleanLogger.info('üíì Heroku keep-alive pulse');
            lastActivityTime = Date.now();
        }, 20 * 60 * 1000); // Every 20 minutes
        
        // Memory monitoring for Heroku
        setInterval(() => {
            const memoryUsage = process.memoryUsage();
            const memoryMB = Math.round(memoryUsage.rss / 1024 / 1024);
            
            if (memoryMB > 300) {
                UltraCleanLogger.warning(`‚ö†Ô∏è High memory usage: ${memoryMB}MB`);
                memoryMonitor.trimCaches(memoryMB > 400);
                if (global.gc) {
                    global.gc();
                    UltraCleanLogger.info('üßπ Forced garbage collection');
                }
            }
        }, 5 * 60 * 1000); // Every 5 minutes
    }
}

async function authenticateWithSessionId(sessionId) {
    try {
        UltraCleanLogger.info('üîÑ Processing Session ID...');
        
        const sessionData = parseWolfBotSession(sessionId);
        
        if (!sessionData) {
            throw new Error('Could not parse session data');
        }
        
        if (!fs.existsSync(SESSION_DIR)) {
            fs.mkdirSync(SESSION_DIR, { recursive: true });
            UltraCleanLogger.info('üìÅ Created session directory');
        }
        
        const filePath = path.join(SESSION_DIR, 'creds.json');
        
        fs.writeFileSync(filePath, JSON.stringify(sessionData, null, 2));
        UltraCleanLogger.success('üíæ Session saved to session/creds.json');
        
        try {
            const envPath = path.join(process.cwd(), '.env');
            if (fs.existsSync(envPath)) {
                const envContent = fs.readFileSync(envPath, 'utf8');
                if (!envContent.includes('SESSION_ID=')) {
                    fs.appendFileSync(envPath, `\nSESSION_ID=${sessionId}\n`);
                    UltraCleanLogger.info('üìù Added SESSION_ID to .env file');
                }
            }
        } catch (envError) {
            // Ignore .env errors
        }
        
        return true;
        
    } catch (error) {
        UltraCleanLogger.error('‚ùå Session authentication failed:', error.message);
        throw error;
    }
}

// ====== LOGIN MANAGER ======
class LoginManager {
    constructor() {
        this.rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout
        });
    }
    
    async selectMode() {
        console.log(chalk.yellow('\nüê∫ WOLFBOT v' + VERSION + ' - LOGIN SYSTEM'));
        console.log(chalk.blue('1) Pairing Code Login (Recommended)'));
        console.log(chalk.blue('2) Clean Session & Start Fresh'));
        console.log(chalk.magenta('3) Use Session ID from Environment'));
        
        const choice = await this.ask('Choose option (1-3, default 1): ');
        
        switch (choice.trim()) {
            case '1':
                return await this.pairingCodeMode();
            case '2':
                return await this.cleanStartMode();
            case '3':
                return await this.sessionIdMode();
            default:
                return await this.pairingCodeMode();
        }
    }
    
    async sessionIdMode() {
        console.log(chalk.magenta('\nüîê SESSION ID LOGIN'));
        
        let sessionId = process.env.SESSION_ID;
        
        if (!sessionId || sessionId.trim() === '') {
            console.log(chalk.yellow('‚ÑπÔ∏è No SESSION_ID found in environment'));
            
            const input = await this.ask('\nWould you like to:\n1) Paste Session ID now\n2) Go back to main menu\nChoice (1-2): ');
            
            if (input.trim() === '1') {
                sessionId = await this.ask('Paste your Session ID (WOLF-BOT:... or base64): ');
                if (!sessionId || sessionId.trim() === '') {
                    console.log(chalk.red('‚ùå No Session ID provided'));
                    return await this.selectMode();
                }
                
                console.log(chalk.green('‚úÖ Session ID received'));
            } else {
                return await this.selectMode();
            }
        } else {
            console.log(chalk.green('‚úÖ Found Session ID in environment'));
            
            const proceed = await this.ask('Use existing Session ID? (y/n, default y): ');
            if (proceed.toLowerCase() === 'n') {
                const newSessionId = await this.ask('Enter new Session ID: ');
                if (newSessionId && newSessionId.trim() !== '') {
                    sessionId = newSessionId;
                    console.log(chalk.green('‚úÖ Session ID updated'));
                }
            }
        }
        
        console.log(chalk.yellow('üîÑ Processing session ID...'));
        try {
            await authenticateWithSessionId(sessionId);
            return { mode: 'session', sessionId: sessionId.trim() };
        } catch (error) {
            console.log(chalk.red('‚ùå Session authentication failed'));
            console.log(chalk.yellow('üìù Falling back to pairing code mode...'));
            return await this.pairingCodeMode();
        }
    }
    
    async pairingCodeMode() {
        console.log(chalk.cyan('\nüì± PAIRING CODE LOGIN'));
        console.log(chalk.gray('Enter phone number with country code (without +)'));
        console.log(chalk.gray('Example: 254788710904'));
        
        const phone = await this.ask('Phone number: ');
        const cleanPhone = phone.replace(/[^0-9]/g, '');
        
        if (!cleanPhone || cleanPhone.length < 10) {
            console.log(chalk.red('‚ùå Invalid phone number'));
            return await this.selectMode();
        }
        
        return { mode: 'pair', phone: cleanPhone };
    }
    
    async cleanStartMode() {
        console.log(chalk.yellow('\n‚ö†Ô∏è CLEAN SESSION'));
        console.log(chalk.red('This will delete all session data!'));
        
        const confirm = await this.ask('Are you sure? (y/n): ');
        
        if (confirm.toLowerCase() === 'y') {
            cleanSession();
            console.log(chalk.green('‚úÖ Session cleaned. Starting fresh...'));
            return await this.pairingCodeMode();
        } else {
            return await this.pairingCodeMode();
        }
    }
    
    ask(question) {
        return new Promise((resolve) => {
            this.rl.question(chalk.yellow(question), (answer) => {
                resolve(answer);
            });
        });
    }
    
    close() {
        if (this.rl) this.rl.close();
    }
}

// ====== TERMINAL HEADER UPDATE ======
function updateTerminalHeader() {
    const currentPrefix = getCurrentPrefix();
    const prefixDisplay = isPrefixless ? 'none (prefixless)' : `"${currentPrefix}"`;
    
    console.clear();
    console.log(chalk.cyan(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë   üê∫ ${chalk.bold(`${BOT_NAME.toUpperCase()} v${VERSION} (PREFIXLESS & MEMBER DETECTION)`)}             
‚ïë   üí¨ Prefix  : ${prefixDisplay}
‚ïë   üîß Auto Fix: ‚úÖ ENABLED
‚ïë   üîÑ Real-time Prefix: ‚úÖ ENABLED
‚ïë   üëÅÔ∏è Status Detector: ‚úÖ ACTIVE
‚ïë   üë• Member Detector: ‚úÖ ACTIVE
‚ïë   üîê Anti-ViewOnce: ‚úÖ ACTIVE
‚ïë   üõ°Ô∏è Rate Limit Protection: ‚úÖ ACTIVE
‚ïë   üîó Auto-Connect on Link: ${AUTO_CONNECT_ON_LINK ? '‚úÖ' : '‚ùå'}
‚ïë   üîÑ Auto-Connect on Start: ${AUTO_CONNECT_ON_START ? '‚úÖ' : '‚ùå'}
‚ïë   üîê Login Methods: Pairing Code | Session ID | Clean Start
‚ïë   üì± Session Support: WOLF-BOT: format & Base64
‚ïë   üìä Log Level: ULTRA CLEAN (Zero spam)
‚ïë   üîä Console: ‚úÖ COMPLETELY FILTERED
‚ïë   ‚ö° SPEED: ‚úÖ OPTIMIZED (FAST RESPONSE)
‚ïë   üéØ Background Auth: ‚úÖ ENABLED
‚ïë   üéâ Welcome/Goodbye: OFF by default (per-group)
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
`));
}

// Initialize with loaded prefix
prefixCache = loadPrefixFromFiles();
isPrefixless = prefixCache === '' ? true : false;
updateTerminalHeader();

// ====== DATABASE INIT ======
async function initDatabase() {
    try {
        UltraCleanLogger.info('üíæ Database: Connecting to PostgreSQL...');
        const ready = await supabaseDb.initTables();
        if (ready && supabaseDb.isAvailable()) {
            UltraCleanLogger.success('üíæ Database: PostgreSQL connected & tables ready');
            await runDataMigrations();
            return true;
        } else {
            UltraCleanLogger.info('üíæ Database: Tables not ready yet, using local JSON fallback.');
            return false;
        }
    } catch (err) {
        UltraCleanLogger.error(`üíæ Database: Init error - ${err.message}`);
        return false;
    }
}

async function runDataMigrations() {
    try {
        UltraCleanLogger.info('üíæ Database: Running data migrations...');
        await initSudo();
        await migrateSudoToSupabase();
        await migrateWarningsToSupabase();

        const configFiles = [
            { file: './bot_mode.json', key: 'bot_mode' },
            { file: './bot_settings.json', key: 'bot_settings' },
            { file: './prefix_config.json', key: 'prefix_config' },
            { file: './owner.json', key: 'owner_data' },
            { file: './whitelist.json', key: 'whitelist' },
            { file: './blocked_users.json', key: 'blocked_users' },
            { file: './data/welcome_data.json', key: 'welcome_data' },
            { file: './data/autoViewConfig.json', key: 'autoview_config' },
            { file: './data/autoReactConfig.json', key: 'autoreact_config' },
            { file: './data/member_detection.json', key: 'member_detection' },
            { file: './data/antiviewonce/config.json', key: 'antiviewonce_config' },
            { file: './data/viewonce_messages/history.json', key: 'antiviewonce_history' },
            { file: './data/status_detection_logs.json', key: 'status_detection_logs' }
        ];

        for (const { file, key } of configFiles) {
            await supabaseDb.migrateJSONToConfig(file, key);
        }

        _cache_owner_data = await _loadConfigCache('owner_data', {});
        _cache_prefix_config = await _loadConfigCache('prefix_config', { prefix: '.' });
        _cache_bot_settings = await _loadConfigCache('bot_settings', {});
        _cache_bot_mode = await _loadConfigCache('bot_mode', { mode: 'public' });
        _cache_whitelist = await _loadConfigCache('whitelist', { whitelist: [] });
        _cache_blocked_users = await _loadConfigCache('blocked_users', { blocked: [] });
        _cache_welcome_data = await _loadConfigCache('welcome_data', {});
        _cache_status_logs = await _loadConfigCache('status_detection_logs', {});
        _cache_member_detection = await _loadConfigCache('member_detection', {});
        _cache_antiviewonce_config = await _loadConfigCache('antiviewonce_config', DEFAULT_ANTIVIEWONCE_CONFIG);
        _cache_antiviewonce_history = await _loadConfigCache('antiviewonce_history', {});

        if (_cache_owner_data && Object.keys(_cache_owner_data).length === 0) _cache_owner_data = null;
        if (_cache_bot_settings && Object.keys(_cache_bot_settings).length === 0) _cache_bot_settings = null;
        if (_cache_welcome_data && Object.keys(_cache_welcome_data).length === 0) _cache_welcome_data = null;

        UltraCleanLogger.success('üíæ Database: Data migration & cache load complete');
    } catch (err) {
        UltraCleanLogger.error(`üíæ Database: Migration error - ${err.message}`);
    }
}

initDatabase().catch(() => {});

// ====== MAIN BOT FUNCTION ======
async function startBot(loginMode = 'auto', loginData = null) {
    try {
        if (connectionStableTimer) { clearTimeout(connectionStableTimer); connectionStableTimer = null; }
        if (SOCKET_INSTANCE) {
            try {
                stopHeartbeat();
                SOCKET_INSTANCE.ev.removeAllListeners();
                SOCKET_INSTANCE.ws.close();
            } catch (closeErr) {}
            SOCKET_INSTANCE = null;
            currentSock = null;
            await new Promise(r => setTimeout(r, 1000));
        }

        hasSentConnectionMessage = false;
        connectionOpenTime = 0;

        UltraCleanLogger.info('üöÄ Initializing WhatsApp connection...');
        
        // Handle different login modes
        if (loginMode === 'session' && loginData) {
            try {
                UltraCleanLogger.info('üîê Processing Session ID...');
                await authenticateWithSessionId(loginData);
                UltraCleanLogger.success('‚úÖ Session saved to session/creds.json');
            } catch (error) {
                UltraCleanLogger.error(`‚ùå Session processing failed: ${error.message}`);
            }
        }
        
        // For 'auto' mode, ensure session directory exists
        if (loginMode === 'auto') {
            ensureSessionDir();
            UltraCleanLogger.info('üîÑ Loading existing session from storage...');
        }
        
        // Rest of your existing startBot function remains the same...
        // ... (keep all the existing code from line 1861)
        
        let commandLoadPromise = Promise.resolve();
        if (!initialCommandsLoaded) {
            UltraCleanLogger.info('üì¶ Loading commands (first time)...');
            commands.clear();
            commandCategories.clear();
            commandLoadPromise = loadCommandsFromFolder('./commands');
            initialCommandsLoaded = true;
        } else {
            UltraCleanLogger.info('üì¶ Commands already loaded, skipping...');
        }
        
        if (!store) store = new MessageStore();
        ensureSessionDir();
        
        if (!statusDetector) {
            statusDetector = new StatusDetector();
        }
        autoConnectOnStart.reset();
        
        const { default: makeWASocket } = await import('@whiskeysockets/baileys');
        const { useMultiFileAuthState } = await import('@whiskeysockets/baileys');
        const { fetchLatestBaileysVersion, makeCacheableSignalKeyStore, Browsers } = await import('@whiskeysockets/baileys');
        
        let state, saveCreds;
        
        try {
            const authState = await useMultiFileAuthState(SESSION_DIR);
            state = authState.state;
            saveCreds = authState.saveCreds;
            
            UltraCleanLogger.info(`üîë Auth state loaded: ${state.creds.registered ? 'Registered' : 'Not registered'}`);
            
        } catch (authError) {
            UltraCleanLogger.error(`‚ùå Auth state error: ${authError.message}`);
            
            try {
                cleanSession();
                UltraCleanLogger.info('üîÑ Creating fresh session...');
                const freshAuth = await useMultiFileAuthState(SESSION_DIR);
                state = freshAuth.state;
                saveCreds = freshAuth.saveCreds;
            } catch (freshError) {
                UltraCleanLogger.error(`‚ùå Fresh session creation failed: ${freshError.message}`);
                throw new Error('Cannot create auth state');
            }
        }
        
        const { version } = await fetchLatestBaileysVersion();
        
        const sock = makeWASocket({
            version,
            logger: ultraSilentLogger,
            browser: Browsers.ubuntu('Chrome'),
            printQRInTerminal: false,
            auth: {
                creds: state.creds,
                keys: makeCacheableSignalKeyStore(state.keys, ultraSilentLogger),
            },
            markOnlineOnConnect: true,
            generateHighQualityLinkPreview: false,
            connectTimeoutMs: 60000,
            keepAliveIntervalMs: 25000,
            emitOwnEvents: true,
            mobile: false,
            msgRetryCounterCache,
            getMessage: async (key) => {
                const storeMsg = store?.getMessage(key.remoteJid, key.id);
                if (storeMsg?.message) {
                    return storeMsg.message;
                }
                return undefined;
            },
            patchMessageBeforeSending: (message) => {
                const requiresPatch = !!(
                    message.buttonsMessage ||
                    message.templateMessage ||
                    message.listMessage ||
                    message.interactiveMessage
                );
                if (requiresPatch) {
                    message = {
                        viewOnceMessage: {
                            message: {
                                messageContextInfo: {
                                    deviceListMetadataVersion: 2,
                                    deviceListMetadata: {},
                                },
                                ...message,
                            },
                        },
                    };
                }
                return message;
            },
            cachedGroupMetadata: async (jid) => {
                const cached = groupMetadataCache.get(jid);
                if (cached && Date.now() - cached.ts < GROUP_CACHE_TTL) {
                    return cached.data;
                }
                return undefined;
            },
            defaultQueryTimeoutMs: 30000,
            retryRequestDelayMs: 250,
            maxRetries: 5,
            fireInitQueries: true,
            syncFullHistory: false,
        });
        
        const originalSendMessage = sock.sendMessage.bind(sock);
        sock.sendMessage = async (jid, content, options, ...rest) => {
            const result = await originalSendMessage(jid, content, options, ...rest);
            try {
                if (result?.key?.id && store) {
                    store.addSentMessage(jid, result.key.id, content);
                }
            } catch {}
            return result;
        };
        
        SOCKET_INSTANCE = sock;
        currentSock = sock;
        isWaitingForPairingCode = false;

        sock.ev.on('connection.update', async (update) => {
            const { connection, lastDisconnect, qr } = update;
            
            if (connection) UltraCleanLogger.info(`üîó Connection update: ${connection}`);
            
            if (connection === 'open') {
                isConnected = true;
                connectionOpenTime = Date.now();
                if (connectionStableTimer) clearTimeout(connectionStableTimer);
                connectionStableTimer = setTimeout(() => {
                    connectionAttempts = 0;
                    conflictCount = 0;
                    isConflictRecovery = false;
                }, 300000);
                startHeartbeat(sock);
                setTimeout(() => {
                    if (isConnected && !isConflictRecovery) handleSuccessfulConnection(sock, loginMode, loginData).catch(() => {});
                }, 2000);
                isWaitingForPairingCode = false;
                
                if (!antiViewOnceSystem) {
                    antiViewOnceSystem = new AntiViewOnceSystem(sock);
                } else {
                    antiViewOnceSystem.sock = sock;
                }
                
                if (sock.user?.id) {
                    setBotId(sock.user.id);
                    setConfigBotId(sock.user.id);
                    initSudo(sock.user.id).catch(() => {});
                    reloadConfigCaches().catch(() => {});
                }

                if (!antideleteInitDone) {
                    antideleteInitDone = true;
                    initAntidelete(sock).catch(err => {
                        console.error('‚ùå Antidelete init error:', err.message);
                        antideleteInitDone = false;
                    });
                } else {
                    updateAntideleteSock(sock);
                }
                
                if (!statusAntideleteInitDone) {
                    statusAntideleteInitDone = true;
                    initStatusAntidelete(sock).catch(err => {
                        console.error('‚ùå Status Antidelete init error:', err.message);
                        statusAntideleteInitDone = false;
                    });
                } else {
                    updateStatusAntideleteSock(sock);
                }
                
                try {
                    const { initAntiLinkListener } = await import('./commands/group/antilink.js');
                    initAntiLinkListener(sock);
                } catch {}

                UltraCleanLogger.info('üîë Sudo system ready (using signal LID mapping)');

                setTimeout(() => {
                    if (isConnected) {
                        autoScanGroupsForSudo(sock).catch(() => {
                            setTimeout(() => {
                                if (isConnected) autoScanGroupsForSudo(sock).catch(() => {});
                            }, 10000);
                        });
                    }
                }, 5000);
                
                setTimeout(() => {
                    if (!isConnected || isConflictRecovery) return;
                    if (!hasSentRestartMessage) {
                        triggerRestartAutoFix(sock).catch(() => {});
                    }
                    if (AUTO_CONNECT_ON_START && !hasSentRestartMessage) {
                        autoConnectOnStart.trigger(sock).catch(() => {});
                    }
                }, 3000);
                
                setTimeout(async () => {
                    try {
                        const autojoinConfigPath = './data/autojoin/config.json';
                        if (!fs.existsSync(autojoinConfigPath)) {
                            return;
                        }
                        const autojoinConfig = JSON.parse(fs.readFileSync(autojoinConfigPath, 'utf8'));

                        let allGroups = null;
                        try {
                            const fetchPromise = sock.groupFetchAllParticipating();
                            const fetchTimeout = new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), 15000));
                            allGroups = await Promise.race([fetchPromise, fetchTimeout]);
                        } catch (_) {}

                        const CHANNEL_JID = "120363424199376597@newsletter";
                        try {
                            await sock.newsletterFollow(CHANNEL_JID);
                            UltraCleanLogger.info(`‚úÖ Auto-followed channel: ${CHANNEL_JID}`);
                        } catch (e) {
                            const errMsg = (e.message || '').toLowerCase();
                            if (errMsg.includes('already') || errMsg.includes('duplicate') || errMsg.includes('not-allowed') || errMsg.includes('conflict')) {
                                UltraCleanLogger.info('‚ÑπÔ∏è Already following channel, skipped');
                            } else {
                                UltraCleanLogger.info(`‚ö†Ô∏è Channel follow failed (non-critical): ${e.message}`);
                            }
                        }

                        for (const groupLink of (autojoinConfig.groupLinks || [])) {
                            try {
                                const inviteCode = groupLink.split('/').pop();
                                if (!inviteCode) continue;

                                let alreadyInGroup = false;
                                try {
                                    const inviteInfo = await sock.groupGetInviteInfo(inviteCode);
                                    if (inviteInfo && inviteInfo.id && allGroups) {
                                        const groupJid = inviteInfo.id.includes('@') ? inviteInfo.id : `${inviteInfo.id}@g.us`;
                                        if (allGroups[groupJid]) {
                                            alreadyInGroup = true;
                                        }
                                    }
                                } catch (_) {}

                                if (alreadyInGroup) {
                                    UltraCleanLogger.info('‚ÑπÔ∏è Already in group, skipped');
                                } else {
                                    try {
                                        await sock.groupAcceptInvite(inviteCode);
                                        UltraCleanLogger.info('‚úÖ Auto-joined group successfully');
                                    } catch (e) {
                                        const errMsg = (e.message || '').toLowerCase();
                                        if (errMsg.includes('already') || errMsg.includes('participant') || errMsg.includes('conflict')) {
                                            UltraCleanLogger.info('‚ÑπÔ∏è Already in group, skipped');
                                        } else {
                                            UltraCleanLogger.info(`‚ö†Ô∏è Group join failed (non-critical): ${e.message}`);
                                        }
                                    }
                                }
                                await new Promise(r => setTimeout(r, 300));
                            } catch (e) {
                                UltraCleanLogger.info(`‚ö†Ô∏è Group processing error: ${e.message}`);
                            }
                        }
                    } catch (e) {
                        UltraCleanLogger.info(`‚ö†Ô∏è Auto-follow/join config error: ${e.message}`);
                    }
                }, 8000);
                
                setTimeout(() => {
                    memoryMonitor.start();
                }, 3000);
                
                // ====== THE ONLY SUCCESS MESSAGE ======
                setTimeout(async () => {
                    if (!isConnected || hasSentConnectionMessage || isConflictRecovery) return;
                    try {
                        const ownerInfo = jidManager.getOwnerInfo();
                        const displayOwnerNumber = ownerInfo?.ownerNumber ? ownerInfo.ownerNumber.split(':')[0] : 'Not set';
                        
                        const successMessage = `‚ï≠‚ä∑„Äé üê∫ WOLFBOT „Äè\n‚îÇ\n‚îú‚ä∑ *Name:* ${BOT_NAME}\n‚îú‚ä∑ *Prefix:* ${getCurrentPrefix() || 'none (prefixless)'}\n‚îú‚ä∑ *Owner:* (${displayOwnerNumber})\n‚îú‚ä∑ *Platform:* ${detectPlatform()}\n‚îú‚ä∑ *Mode:* ${BOT_MODE}\n‚îî‚ä∑ *Status:* ‚úÖ Connected\n\n‚ï∞‚ä∑ *Silent Wolf Online* üêæ`;
                        
                        const targetJid = (ownerInfo && ownerInfo.ownerJid) ? ownerInfo.ownerJid : sock.user.id;
                        const sendPromise = sock.sendMessage(targetJid, { text: successMessage });
                        const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), 10000));
                        await Promise.race([sendPromise, timeoutPromise]);
                        console.log(chalk.green(`‚úÖ Connection message sent to owner`));
                        hasSentConnectionMessage = true;
                    } catch (sendError) {
                        console.log(chalk.red('‚ùå Could not send connection message:'), sendError.message);
                        hasSentConnectionMessage = true;
                    }
                }, 5000);
                
            }
            
            if (connection === 'close') {
                isConnected = false;
                if (connectionStableTimer) { clearTimeout(connectionStableTimer); connectionStableTimer = null; }
                stopHeartbeat();
                
                const closeCode = lastDisconnect?.error?.output?.statusCode || 'unknown';
                const closeMsg = lastDisconnect?.error?.message || '';
                UltraCleanLogger.info(`üîó Close reason: ${closeCode} - ${closeMsg}`);
                
                memoryMonitor.stop();
                
                if (statusDetector) {
                    statusDetector.saveStatusLogs();
                }
                
                if (memberDetector) {
                    memberDetector.saveDetectionData();
                }
                
                if (antiViewOnceSystem) {
                    antiViewOnceSystem.saveHistory();
                }
                
                try {
                    if (typeof autoGroupJoinSystem !== 'undefined' && autoGroupJoinSystem) {
                        UltraCleanLogger.info('üíæ Saving auto-join logs...');
                    }
                } catch (error) {
                    UltraCleanLogger.warning(`Could not save auto-join logs: ${error.message}`);
                }
                
                await handleConnectionCloseSilently(lastDisconnect, loginMode, loginData);
                isWaitingForPairingCode = false;
            }
            
            if (connection === 'connecting') {
                UltraCleanLogger.info('üîÑ Establishing connection...');
            }
            
            if (loginMode === 'pair' && loginData && !state.creds.registered && (qr || connection === 'connecting')) {
                if (!isWaitingForPairingCode) {
                    isWaitingForPairingCode = true;
                    
                    console.log(chalk.cyan('\nüì± CONNECTING TO WHATSAPP...'));
                    console.log(chalk.yellow('Requesting 8-digit pairing code...'));
                    
                    const requestPairingCode = async (attempt = 1) => {
                        try {
                            const code = await sock.requestPairingCode(loginData);
                            const cleanCode = code.replace(/\s+/g, '');
                            let formattedCode = cleanCode;
                            
                            if (cleanCode.length === 8) {
                                formattedCode = `${cleanCode.substring(0, 4)}-${cleanCode.substring(4, 8)}`;
                            }
                            
                            console.clear();
                            console.log(chalk.greenBright(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                    üîó PAIRING CODE - ${BOT_NAME}                    ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë üìû Phone  : ${chalk.cyan(loginData.padEnd(40))}‚ïë
‚ïë üîë Code   : ${chalk.yellow.bold(formattedCode.padEnd(39))}‚ïë
‚ïë üìè Length : ${chalk.cyan('8 characters'.padEnd(38))}‚ïë
‚ïë ‚è∞ Expires : ${chalk.red('10 minutes'.padEnd(38))}‚ïë
‚ïë üîó Group   : ${chalk.blue(GROUP_NAME.substring(0, 38).padEnd(38))}‚ïë
‚ïë üë• Member Detector: ‚úÖ ENABLED
‚ïë üîê Anti-ViewOnce: ‚úÖ ENABLED
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
`));
                            
                            console.log(chalk.cyan('\nüì± INSTRUCTIONS:'));
                            console.log(chalk.white('1. Open WhatsApp on your phone'));
                            console.log(chalk.white('2. Go to Settings ‚Üí Linked Devices'));
                            console.log(chalk.white('3. Tap "Link a Device"'));
                            console.log(chalk.white('4. Enter this 8-digit code:'));
                            console.log(chalk.yellow.bold(`\n   ${formattedCode}\n`));
                      
                            
                            let remainingTime = 600;
                            const timerInterval = setInterval(() => {
                                if (remainingTime <= 0 || isConnected) {
                                    clearInterval(timerInterval);
                                    return;
                                }
                                
                                const minutes = Math.floor(remainingTime / 60);
                                const seconds = remainingTime % 60;
                                process.stdout.write(`\r‚è∞ Code expires in: ${minutes}:${seconds.toString().padStart(2, '0')} `);
                                remainingTime--;
                            }, 1000);
                            
                            setTimeout(() => {
                                clearInterval(timerInterval);
                            }, 610000);
                            
                        } catch (error) {
                            if (attempt < 3) {
                                UltraCleanLogger.warning(`Pairing code attempt ${attempt} failed, retrying...`);
                                await delay(3000);
                                await requestPairingCode(attempt + 1);
                            } else {
                                console.log(chalk.red('\n‚ùå Max retries reached. Restarting bot...'));
                                UltraCleanLogger.error(`Pairing code error: ${error.message}`);
                                
                                setTimeout(async () => {
                                    await startBot(loginMode, loginData);
                                }, 8000);
                            }
                        }
                    };
                    
                    const pairDelay = qr ? 500 : 3000;
                    setTimeout(() => {
                        requestPairingCode(1);
                    }, pairDelay);
                }
            }
        });
        
        let credsTimer = null;
        let credsPending = false;
        const debouncedSaveCreds = () => {
            credsPending = true;
            if (credsTimer) clearTimeout(credsTimer);
            credsTimer = setTimeout(async () => {
                credsPending = false;
                try {
                    const freeMB = await DiskManager.getDiskFreeAsync();
                    if (freeMB !== null && freeMB < DiskManager.CRITICAL_MB) {
                        UltraCleanLogger.warning(`üíæ Low disk (${freeMB}MB) before saveCreds - cleaning first...`);
                        await DiskManager.runCleanupAsync(true);
                    } else if (DiskManager.isLow) {
                        await DiskManager.runCleanupAsync(true);
                    }
                } catch {}
                try {
                    await saveCreds();
                } catch (err) {
                    if (err?.code === 'ENOSPC') {
                        UltraCleanLogger.error('üíæ Disk full during saveCreds! Running emergency cleanup...');
                        await DiskManager.runCleanupAsync(true);
                        await new Promise(r => setTimeout(r, 1000));
                        try { await saveCreds(); } catch (e2) {
                            UltraCleanLogger.error(`üíæ saveCreds still failing after cleanup: ${e2.message}`);
                        }
                    }
                }
            }, 500);
        };
        const flushCreds = () => {
            if (credsPending && credsTimer) {
                clearTimeout(credsTimer);
                credsPending = false;
                try { saveCreds(); } catch {}
            }
        };
        if (global._flushCredsExit) process.removeListener('exit', global._flushCredsExit);
        if (global._flushCredsTerm) process.removeListener('SIGTERM', global._flushCredsTerm);
        global._flushCredsExit = flushCreds;
        global._flushCredsTerm = flushCreds;
        process.on('exit', flushCreds);
        process.on('SIGTERM', flushCreds);
        sock.ev.on('creds.update', debouncedSaveCreds);

        sock.ev.on('contacts.upsert', (contacts) => {
            try {
                global.contactNames = global.contactNames || new Map();
                for (const contact of contacts) {
                    if (contact.id && contact.lid) {
                        const idNum = contact.id.split('@')[0].split(':')[0];
                        const lidNum = contact.lid.split('@')[0].split(':')[0];
                        const idIsLid = contact.id.includes('@lid');
                        if (!idIsLid && idNum !== lidNum) {
                            cacheLidPhone(lidNum, idNum);
                        }
                    }
                    const displayName = contact.notify || contact.name || contact.vname || contact.short || contact.pushName || contact.verifiedName;
                    if (displayName && contact.id) {
                        const jidKey = contact.id.split('@')[0];
                        global.contactNames.set(jidKey, displayName);
                        const cleanKey = jidKey.split(':')[0];
                        if (cleanKey !== jidKey) global.contactNames.set(cleanKey, displayName);
                        if (contact.id.includes('@lid')) {
                            global.contactNames.set(contact.id, displayName);
                        }
                        if (contact.lid) {
                            const lidKey = contact.lid.split('@')[0].split(':')[0];
                            global.contactNames.set(lidKey, displayName);
                            global.contactNames.set(contact.lid.split('@')[0], displayName);
                        }
                    }
                }
            } catch {}
        });

        sock.ev.on('contacts.update', (updates) => {
            try {
                global.contactNames = global.contactNames || new Map();
                for (const contact of updates) {
                    if (contact.id && contact.lid) {
                        const idNum = contact.id.split('@')[0].split(':')[0];
                        const lidNum = contact.lid.split('@')[0].split(':')[0];
                        const idIsLid = contact.id.includes('@lid');
                        if (!idIsLid && idNum !== lidNum) {
                            cacheLidPhone(lidNum, idNum);
                        }
                    }
                    const displayName = contact.notify || contact.name || contact.vname || contact.short || contact.pushName || contact.verifiedName;
                    if (displayName && contact.id) {
                        const jidKey = contact.id.split('@')[0];
                        global.contactNames.set(jidKey, displayName);
                        const cleanKey = jidKey.split(':')[0];
                        if (cleanKey !== jidKey) global.contactNames.set(cleanKey, displayName);
                        if (contact.id.includes('@lid')) {
                            global.contactNames.set(contact.id, displayName);
                        }
                        if (contact.lid) {
                            const lidKey = contact.lid.split('@')[0].split(':')[0];
                            global.contactNames.set(lidKey, displayName);
                            global.contactNames.set(contact.lid.split('@')[0], displayName);
                        }
                    }
                }
            } catch {}
        });

        await commandLoadPromise;
        if (!commandsLoaded) {
            UltraCleanLogger.success(`‚úÖ Loaded ${commands.size} commands`);
            commandsLoaded = true;
        }
        
        sock.ev.on('group-participants.update', async (update) => {
            try {
                if (memberDetector && memberDetector.enabled) {
                    const newMembers = await memberDetector.detectNewMembers(sock, update);
                    if (newMembers && newMembers.length > 0) {
                        UltraCleanLogger.info(`üë• Detected ${newMembers.length} new members in group`);
                    }
                }
            } catch (error) {
                UltraCleanLogger.warning(`Member detection error: ${error.message}`);
            }
            
            try {
                const groupId = update.id;
                const rawParticipants = update.participants || [];
                const participants = rawParticipants.map(p => {
                    if (typeof p === 'string') return p.includes('@') ? p : null;
                    if (p && typeof p === 'object') {
                        const jid = p.jid || p.id || p.userJid || p.participant || p.user;
                        if (typeof jid === 'string' && jid.includes('@')) return jid;
                        if (typeof jid === 'string' && /^\d+$/.test(jid)) return `${jid}@s.whatsapp.net`;
                        const keys = Object.keys(p);
                        for (const key of keys) {
                            const val = p[key];
                            if (typeof val === 'string' && val.includes('@s.whatsapp.net')) return val;
                        }
                        UltraCleanLogger.warning(`Unknown participant shape: ${JSON.stringify(p).substring(0, 200)}`);
                        return null;
                    }
                    return null;
                }).filter(p => p && p.includes('@'));
                
                if (update.action === 'add' && participants.length > 0) {
                    if (await isWelcomeEnabled(groupId)) {
                        const welcomeMsg = await getWelcomeMessage(groupId);
                        UltraCleanLogger.info(`üéâ Welcoming ${participants.length} new member(s) in ${groupId.split('@')[0]}`);
                        sendWelcomeMessage(sock, groupId, participants, welcomeMsg).catch(() => {});
                    }
                }
                
                if ((update.action === 'remove' || update.action === 'leave') && participants.length > 0) {
                    if (isGoodbyeEnabled(groupId)) {
                        const goodbyeMsg = getGoodbyeMessage(groupId);
                        UltraCleanLogger.info(`üëã Saying goodbye to ${participants.length} member(s) in ${groupId.split('@')[0]}`);
                        sendGoodbyeMessage(sock, groupId, participants, goodbyeMsg).catch(() => {});
                    }
                }

                if (update.action === 'demote' || update.action === 'promote') {
                    originalConsoleMethods.log(`üõ°Ô∏è [EVENT] ${update.action} detected in ${groupId.split('@')[0]} | author: ${update.author || 'unknown'} | participants: ${JSON.stringify(rawParticipants)}`);
                    try {
                        antidemoteHandler(sock, update).catch(() => {});
                    } catch (adErr) {
                        originalConsoleMethods.log(`‚ùå [ANTIDEMOTE] Handler error: ${adErr.message}`);
                    }
                }
            } catch (error) {
                UltraCleanLogger.warning(`Welcome/Goodbye system error: ${error.message}`);
            }
        });

        sock.ev.on('messages.upsert', async ({ messages, type }) => {
            if (type !== 'notify') return;
            const msg = messages[0];
            if (!msg) return;
            
            const _upsertTs = msg.messageTimestamp ? (typeof msg.messageTimestamp === 'object' ? msg.messageTimestamp.low || 0 : Number(msg.messageTimestamp)) * 1000 : 0;
            const _isOldMsg = _upsertTs > 0 && (Date.now() - _upsertTs > 60000 || (connectionOpenTime > 0 && _upsertTs < connectionOpenTime - 5000));
            
            if (_isOldMsg) return;
            
            if (store && msg?.key?.remoteJid && msg?.key?.id && msg?.message) {
                store.addMessage(msg.key.remoteJid, msg.key.id, msg);
                const voCheck = detectViewOnceMedia(msg.message);
                if (voCheck) {
                    cacheViewOnceMessage(msg.key.remoteJid, msg.key.id, msg);
                } else {
                    const msgKeys = Object.keys(msg.message);
                    const hasVoKey = msgKeys.some(k => k.includes('viewOnce') || k.includes('ViewOnce'));
                    if (hasVoKey) {
                        cacheViewOnceMessage(msg.key.remoteJid, msg.key.id, msg);
                    }
                }
            }

            if (!msg.message) {
                if (store && msg.key?.remoteJid && msg.key?.id) {
                    store.addMessage(msg.key.remoteJid, msg.key.id, msg);
                }

                if (msg.key?.remoteJid === 'status@broadcast' && msg.messageStubType) {
                    statusAntideleteHandleUpdate({
                        key: msg.key,
                        update: { message: null, messageStubType: msg.messageStubType }
                    }).catch(() => {});
                    return;
                }

                if (msg.messageStubType === 29 || msg.messageStubType === 30) {
                    const stubAction = msg.messageStubType === 29 ? 'promote' : 'demote';
                    const groupId = msg.key.remoteJid;
                    const author = msg.key.participant || msg.participant;
                    const affectedJids = msg.messageStubParameters || [];

                    if (groupId && groupId.endsWith('@g.us') && affectedJids.length > 0) {
                        originalConsoleMethods.log(`üõ°Ô∏è [STUB] ${stubAction} detected in ${groupId.split('@')[0]} by ${author?.split('@')[0] || 'unknown'} | jids: ${JSON.stringify(affectedJids)}`);
                        antidemoteHandler(sock, {
                            id: groupId,
                            participants: affectedJids,
                            action: stubAction,
                            author: author
                        }).catch(err => {
                            originalConsoleMethods.log(`‚ùå [ANTIDEMOTE] Stub handler error: ${err.message}`);
                        });
                    }
                }
                return;
            }

            if (msg.messageStubType === 29 || msg.messageStubType === 30) {
                const stubAction = msg.messageStubType === 29 ? 'promote' : 'demote';
                const groupId = msg.key.remoteJid;
                const author = msg.key.participant || msg.participant;
                const affectedJids = msg.messageStubParameters || [];

                if (groupId && groupId.endsWith('@g.us') && affectedJids.length > 0) {
                    originalConsoleMethods.log(`üõ°Ô∏è [STUB+MSG] ${stubAction} detected in ${groupId.split('@')[0]} by ${author?.split('@')[0] || 'unknown'} | jids: ${JSON.stringify(affectedJids)}`);
                    antidemoteHandler(sock, {
                        id: groupId,
                        participants: affectedJids,
                        action: stubAction,
                        author: author
                    }).catch(err => {
                        originalConsoleMethods.log(`‚ùå [ANTIDEMOTE] Stub+msg handler error: ${err.message}`);
                    });
                }
            }

            if (msg.key?.remoteJid !== 'status@broadcast' && (msg.messageStubType || msg.labels?.length > 0)) return;

            const normalizedUpsertContent = normalizeMessageContent(msg.message) || msg.message;
            const upsertProtoMsg = normalizedUpsertContent?.protocolMessage;
            if (upsertProtoMsg && (upsertProtoMsg.type === 0 || upsertProtoMsg.type === 4)) {
                const revokedMsgId = upsertProtoMsg.key?.id;
                if (revokedMsgId) {
                    const revokedChatJid = upsertProtoMsg.key?.remoteJid || msg.key?.remoteJid;
                    if (msg.key?.remoteJid === 'status@broadcast' || revokedChatJid === 'status@broadcast') {
                        console.log(`[STATUS-AD] Protocol revoke detected via upsert for ${revokedMsgId}`);
                        statusAntideleteHandleUpdate({
                            key: { ...msg.key, id: revokedMsgId },
                            update: { message: null, messageStubType: 1 }
                        }).catch(err => {
                            originalConsoleMethods.log(`‚ùå [STATUS-AD] Revoke handle error: ${err.message}`);
                        });
                    } else {
                        console.log(`[ANTIDELETE] Protocol revoke detected via upsert for ${revokedMsgId} in ${revokedChatJid}`);
                        antideleteHandleUpdate({
                            key: { ...msg.key, id: revokedMsgId, remoteJid: revokedChatJid },
                            update: { message: null, messageStubType: 1 }
                        }).catch(err => {
                            console.log(`‚ùå [ANTIDELETE] Revoke handle error: ${err.message}`);
                        });
                    }
                }
                return;
            }

            if (msg.pushName && msg.key) {
                const senderJid = msg.key.participant || msg.key.remoteJid;
                if (senderJid && !senderJid.includes('status') && !senderJid.includes('broadcast')) {
                    global.contactNames = global.contactNames || new Map();
                    if (global.contactNames.size > 1000) {
                        const excess = global.contactNames.size - 500;
                        let removed = 0;
                        for (const k of global.contactNames.keys()) {
                            if (removed >= excess) break;
                            global.contactNames.delete(k);
                            removed++;
                        }
                    }
                    global.contactNames.set(senderJid.split(':')[0].split('@')[0], msg.pushName);
                    global.contactNames.set(senderJid.split('@')[0], msg.pushName);
                }
            }

            lastActivityTime = Date.now();
            
            handleIncomingMessage(sock, msg).catch(() => {});

            handleReactOwner(sock, msg).catch(() => {});

            handleReactDev(sock, msg).catch(() => {});

            handleViewOnceDetection(sock, msg).catch(err => {
                originalConsoleMethods.log('‚ùå [AV] Detection error:', err.message);
            });
            
            if (msg.key?.remoteJid === 'status@broadcast') {
                handleAutoView(sock, msg.key).catch(() => {});
                handleAutoReact(sock, msg.key).catch(() => {});
                if (statusDetector) {
                    statusDetector.detectStatusUpdate(msg).catch(() => {});
                }
                try {
                    statusMentionHandler(sock, msg).catch(() => {});
                } catch {}
                const normalizedContent = normalizeMessageContent(msg.message) || msg.message;
                const protoMsg = normalizedContent?.protocolMessage;
                if (protoMsg && (protoMsg.type === 0 || protoMsg.type === 4)) {
                    const revokedId = protoMsg.key?.id;
                    if (revokedId) {
                        statusAntideleteHandleUpdate({
                            key: { ...msg.key, id: revokedId },
                            update: { message: null, messageStubType: 1 }
                        }).catch(() => {});
                    }
                } else {
                    statusAntideleteStoreMessage(msg).catch(() => {});
                }
                return;
            }
            
            if (msg.key?.remoteJid?.endsWith('@newsletter')) {
                handleChannelReact(sock, msg).catch(() => {});
            }

            const messageId = msg.key.id;
            
            if (store) {
                store.addMessage(msg.key.remoteJid, messageId, msg);
            }

            antideleteStoreMessage(msg).catch(() => {});
        });
        
        sock.ev.on('messages.reaction', async (reactions) => {
            for (const reaction of reactions) {
                try {
                    if (!reaction.reaction?.text || !reaction.key) continue;
                    
                    const reactedKey = reaction.key;
                    const reactedMsgId = reactedKey.id;
                    const reactedChatId = reactedKey.remoteJid;
                    const reactionEmoji = reaction.reaction.text;
                    const reactorJid = reaction.reaction.key?.participant || reaction.reaction.key?.remoteJid;
                    
                    if (!reactedChatId || !reactedMsgId) continue;
                    
                    let cachedMsg = getViewOnceFromCache(reactedChatId, reactedMsgId);
                    const fromVoCache = !!cachedMsg;
                    if (!cachedMsg) {
                        cachedMsg = store?.getMessage(reactedChatId, reactedMsgId);
                    }
                    if (!cachedMsg || !cachedMsg.message) continue;
                    
                    let viewOnce = detectViewOnceMedia(cachedMsg.message);
                    if (!viewOnce) {
                        const cachedContent = normalizeMessageContent(cachedMsg.message);
                        if (cachedContent) {
                            viewOnce = detectViewOnceMedia(cachedContent);
                        }
                    }
                    if (!viewOnce) continue;
                    
                    const config = loadAntiViewOnceConfig();
                    const ownerJid = config.ownerJid || OWNER_CLEAN_JID;
                    if (!ownerJid) continue;
                    
                    const { type, media } = viewOnce;
                    const cleanMedia = { ...media };
                    delete cleanMedia.viewOnce;
                    
                    const dlMsg = {
                        key: { remoteJid: reactedChatId, id: reactedMsgId, participant: reactedKey.participant, fromMe: reactedKey.fromMe },
                        message: { [`${type}Message`]: cleanMedia }
                    };
                    
                    const silentLogger = { level: 'silent', trace: () => {}, debug: () => {}, info: () => {}, warn: () => {}, error: () => {}, fatal: () => {}, child: () => ({ level: 'silent', trace: () => {}, debug: () => {}, info: () => {}, warn: () => {}, error: () => {}, fatal: () => {}, child: () => ({}) }) };
                    
                    try {
                        const buffer = await Promise.race([
                            downloadMediaMessage(dlMsg, 'buffer', {}, { logger: silentLogger, reuploadRequest: sock.updateMediaMessage }),
                            new Promise((_, rej) => setTimeout(() => rej(new Error('dl_timeout')), 15000))
                        ]);
                        
                        if (buffer && buffer.length > 0) {
                            const normalizedOwner = jidNormalizedUser(ownerJid);
                            const reactorShort = (reactorJid || 'unknown').split('@')[0].split(':')[0];
                            const senderJid = reactedKey.participant || reactedChatId;
                            
                            let stickerMode = false;
                            try {
                                const lcf = './data/antiviewonce/config.json';
                                if (fs.existsSync(lcf)) {
                                    const lcp = JSON.parse(fs.readFileSync(lcf, 'utf8'));
                                    if (lcp?.sendAsSticker === true && type === 'image') stickerMode = true;
                                }
                            } catch {}
                            
                            const mediaPayload = {};
                            if (stickerMode) {
                                mediaPayload.sticker = buffer;
                            } else {
                                mediaPayload[type] = buffer;
                                mediaPayload.caption = await generateRetrievalCaption(senderJid, reactorJid || 'unknown', reactedChatId, null, sock);
                            }
                            
                            await sock.sendMessage(normalizedOwner, mediaPayload);
                            UltraCleanLogger.info(`üîê View-once captured via reaction ${reactionEmoji} from ${reactorShort}`);
                        }
                    } catch (dlErr) {
                        try {
                            const { downloadContentFromMessage } = await import('@whiskeysockets/baileys');
                            const stream = await Promise.race([
                                downloadContentFromMessage(cleanMedia, type),
                                new Promise((_, rej) => setTimeout(() => rej(new Error('dl_timeout')), 15000))
                            ]);
                            const chunks = [];
                            for await (const chunk of stream) {
                                chunks.push(chunk);
                                if (chunks.length > 500) break;
                            }
                            const buffer = Buffer.concat(chunks);
                            if (buffer && buffer.length > 0) {
                                const normalizedOwner = jidNormalizedUser(ownerJid);
                                const reactorShort = (reactorJid || 'unknown').split('@')[0].split(':')[0];
                                const senderJid = reactedKey.participant || reactedChatId;
                                
                                let stickerMode2 = false;
                                try {
                                    const lcf2 = './data/antiviewonce/config.json';
                                    if (fs.existsSync(lcf2)) {
                                        const lcp2 = JSON.parse(fs.readFileSync(lcf2, 'utf8'));
                                        if (lcp2?.sendAsSticker === true && type === 'image') stickerMode2 = true;
                                    }
                                } catch {}
                                
                                const mediaPayload = {};
                                if (stickerMode2) {
                                    mediaPayload.sticker = buffer;
                                } else {
                                    mediaPayload[type] = buffer;
                                    mediaPayload.caption = await generateRetrievalCaption(senderJid, reactorJid || 'unknown', reactedChatId, null, sock);
                                }
                                await sock.sendMessage(normalizedOwner, mediaPayload);
                                UltraCleanLogger.info(`üîê View-once captured via reaction ${reactionEmoji} (fallback) from ${reactorShort}`);
                            }
                        } catch {}
                    }
                } catch (err) {
                    if (err.message !== 'dl_timeout') {
                        UltraCleanLogger.warning(`üîê View-once reaction capture failed: ${err.message}`);
                    }
                }
            }
        });
        
        sock.ev.on('messages.update', (updates) => {
            for (const update of updates) {
                const updateChatJid = update.key?.remoteJid;
                if (updateChatJid === 'status@broadcast') {
                    statusAntideleteHandleUpdate(update).catch(() => {});
                } else {
                    antideleteHandleUpdate(update).catch(() => {});
                }

                try {
                    if (update.update?.message && !update.key?.fromMe) {
                        const updatedMsg = {
                            key: update.key,
                            message: update.update.message
                        };
                        handleViewOnceDetection(sock, updatedMsg).catch(() => {});
                    }
                } catch {}
            }
        });
        
        await commandLoadPromise;
        
        if (!commandsLoaded) {
            UltraCleanLogger.success(`‚úÖ Loaded ${commands.size} commands`);
            commandsLoaded = true;
        }
        
        setTimeout(() => {
            if (!isConnected) {
                UltraCleanLogger.warning('‚ö†Ô∏è Connection taking longer than expected...');
            }
        }, 10000);
        
        return sock;
        
    } catch (error) {
        UltraCleanLogger.error(`‚ùå Connection failed: ${error.message}`);
        
        if (error.message.includes('auth') || error.message.includes('session')) {
            UltraCleanLogger.warning('üîÑ Session issue detected, cleaning session and retrying...');
            cleanSession();
        }
        
        setTimeout(async () => {
            UltraCleanLogger.info('üîÑ Retrying connection...');
            await startBot(loginMode, loginData);
        }, 8000);
    }
}

// ====== RESTART AUTO-FIX TRIGGER ======
async function triggerRestartAutoFix(sock) {
    try {
        if (sock.user?.id) {
            const ownerJid = sock.user.id;
            const cleaned = jidManager.cleanJid(ownerJid);
            
            if (!hasSentRestartMessage) {
                const currentPrefix = getCurrentPrefix();
                const prefixDisplay = isPrefixless ? 'none (prefixless)' : `"${currentPrefix}"`;
                const restartMsg = `üîÑ *BOT RESTARTED SUCCESSFULLY!*\n\n` +
                                 `‚úÖ *${BOT_NAME} v${VERSION}* is now online\n` +
                                 `üëë Owner: +${cleaned.cleanNumber}\n` +
                                 `üí¨ Prefix: ${prefixDisplay}\n` +
                                 `üëÅÔ∏è Status Detector: ‚úÖ ACTIVE\n` +
                                 `üë• Member Detector: ‚úÖ ACTIVE\n` +
                                 `üîê Anti-ViewOnce: ‚úÖ ACTIVE\n\n` +
                                 `üéâ All features are ready!\n` +
                                 `üí¨ Try using ${currentPrefix ? currentPrefix + 'ping' : 'ping'} to verify.`;
                
                await sock.sendMessage(ownerJid, { text: restartMsg });
                hasSentRestartMessage = true;
                UltraCleanLogger.success('‚úÖ Restart message sent to owner');
            }
            
            if (ultimateFixSystem.shouldRunRestartFix(ownerJid)) {
                UltraCleanLogger.info(`üîß Triggering restart auto-fix for: ${ownerJid}`);
                
                ultimateFixSystem.markRestartFixAttempted();
                
                const fixResult = await ultimateFixSystem.applyUltimateFix(sock, ownerJid, cleaned, false, true);
                
                if (fixResult.success) {
                    UltraCleanLogger.success('‚úÖ Restart auto-fix completed');
                }
            }

        }
    } catch (error) {
        UltraCleanLogger.warning(`‚ö†Ô∏è Restart auto-fix error: ${error.message}`);
    }
}

async function handleSuccessfulConnection(sock, loginMode, loginData) {
    const currentTime = new Date().toLocaleTimeString();
    
    OWNER_JID = sock.user.id;
    OWNER_NUMBER = OWNER_JID.split('@')[0];
    
    const isAutoReconnect = loginMode === 'auto';
    
    const currentConnectedNumber = jidManager.cleanJid(OWNER_JID).cleanNumber;
    const existingOwnerNumber = jidManager.owner?.cleanNumber || null;
    
    if (!existingOwnerNumber || existingOwnerNumber !== currentConnectedNumber) {
        UltraCleanLogger.info(`üîÑ Updating owner to connected account: ${currentConnectedNumber}`);
        jidManager.setNewOwner(OWNER_JID, false);
    } else {
        jidManager.loadOwnerData();
    }
    
    const ownerInfo = jidManager.getOwnerInfo();
    const currentPrefix = getCurrentPrefix();
    const prefixDisplay = isPrefixless ? 'none (prefixless)' : `"${currentPrefix}"`;
    const platform = detectPlatform();
    
    updateTerminalHeader();
    
    let connectionMethod = '';
    if (loginMode === 'auto') {
        connectionMethod = 'AUTO-RECONNECT';
    } else if (loginMode === 'session') {
        connectionMethod = 'SESSION ID';
    } else {
        connectionMethod = 'PAIR CODE';
    }
    
// Remove auto-join from the connection success display:
console.log(chalk.greenBright(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                    üê∫ ${chalk.bold('WOLFBOT ONLINE')} - v${VERSION} (PREFIXLESS & MEMBER DETECTION) ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  ‚úÖ ${isAutoReconnect ? 'Auto-reconnected' : 'Connected'} successfully!                            
‚ïë  üëë Owner : +${ownerInfo.ownerNumber}
‚ïë  üîß Clean JID : ${ownerInfo.ownerJid}
‚ïë  üîó LID : ${ownerInfo.ownerLid || 'Not set'}
‚ïë  üì± Device : ${chalk.cyan(`${BOT_NAME} - Chrome`)}       
‚ïë  üïí Time   : ${chalk.yellow(currentTime)}                 
‚ïë  üî• Status : ${chalk.redBright('24/7 Ready!')}         
‚ïë  üí¨ Prefix : ${prefixDisplay}
‚ïë  üéõÔ∏è Mode   : ${BOT_MODE}
‚ïë  üîê Method : ${chalk.cyan(connectionMethod)}  
‚ïë  üìä Commands: ${commands.size} commands loaded
‚ïë  üîß AUTO ULTIMATE FIX : ‚úÖ ENABLED
‚ïë  üëÅÔ∏è STATUS DETECTOR  : ‚úÖ ACTIVE
‚ïë  üë• MEMBER DETECTOR  : ‚úÖ ACTIVE
‚ïë  üîê ANTI-VIEWONCE    : ‚úÖ ACTIVE
‚ïë  üóëÔ∏è ANTIDELETE       : ‚úÖ ALWAYS ACTIVE
‚ïë  üõ°Ô∏è RATE LIMIT PROTECTION : ‚úÖ ACTIVE
‚ïë  üîó AUTO-CONNECT ON LINK: ${AUTO_CONNECT_ON_LINK ? '‚úÖ' : '‚ùå'}
‚ïë  üîÑ AUTO-CONNECT ON START: ${AUTO_CONNECT_ON_START ? '‚úÖ' : '‚ùå'}
‚ïë  üîê AUTO-RECONNECT : ‚úÖ ENABLED
‚ïë  üèóÔ∏è Platform : ${detectPlatform()}
‚ïë  üîä CONSOLE FILTER : ‚úÖ ULTRA CLEAN ACTIVE
‚ïë  ‚ö° RESPONSE SPEED : ‚úÖ OPTIMIZED
‚ïë  üéØ BACKGROUND AUTH : ‚úÖ ENABLED
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
`));
    
    // Only send welcome message if not auto-reconnecting
    if (!isAutoReconnect && isFirstConnection && !hasSentWelcomeMessage) {
        try {
            const start = Date.now();
            const cleaned = jidManager.cleanJid(OWNER_JID);
            
            const loadingMessage = await sock.sendMessage(OWNER_JID, {
                text: `üê∫ *${BOT_NAME}* is starting up... ‚ñà‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí`
            });

            const latency = Date.now() - start;
            
            const uptime = process.uptime();
            const hours = Math.floor(uptime / 3600);
            const minutes = Math.floor((uptime % 3600) / 60);
            const seconds = Math.floor(uptime % 60);
            const uptimeText = `${hours}h ${minutes}m ${seconds}s`;
            
            await sock.sendMessage(OWNER_JID, {
                text: `
‚ï≠‚îÅ‚îÅüåï *WELCOME TO ${BOT_NAME.toUpperCase()}* üåï‚îÅ‚îÅ‚ïÆ
‚îÉ  ‚ö° *User:* ${cleaned.cleanNumber}
‚îÉ  üî¥ *Prefix:* ${prefixDisplay}
‚îÉ  üêæ *Ultimatefix:* ‚úÖ 
‚îÉ  üèóÔ∏è *Platform:* ${platform}
‚îÉ  ‚è±Ô∏è *Latency:* ${latency}ms
‚îÉ  ‚è∞ *Uptime:* ${uptimeText}
‚îÉ  üë• *Member Detection:* ‚úÖ ACTIVE
‚îÉ  üîê *Anti-ViewOnce:* ‚úÖ ACTIVE
‚îÉ  üîó *Status:* ‚úÖ Connected
‚îÉ  üéØ *Mood:* Ready to Serve
‚îÉ  üëë *Owner:* ‚úÖ Yes
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ
_üê∫ The Moon Watches ‚Äî Welcome New Owner_
`,
                edit: loadingMessage.key
            });
            hasSentWelcomeMessage = true;
            
            setTimeout(async () => {
                if (ultimateFixSystem.isFixNeeded(OWNER_JID)) {
                    await ultimateFixSystem.applyUltimateFix(sock, OWNER_JID, cleaned, true);
                }
            }, 500);
        } catch {
            // Silent fail
        }
    } else if (isAutoReconnect) {
        UltraCleanLogger.success('‚úÖ Auto-reconnect completed silently (no message sent to avoid spam)');
    }
}

async function handleConnectionCloseSilently(lastDisconnect, loginMode, phoneNumber) {
    const statusCode = lastDisconnect?.error?.output?.statusCode;
    const { DisconnectReason } = await import('@whiskeysockets/baileys');
    
    connectionAttempts++;
    isConnected = false;
    
    const loggedOut = statusCode === DisconnectReason.loggedOut;
    
    if (loggedOut) {
        UltraCleanLogger.warning('Session logged out. Cleaning session and restarting...');
        cleanSession();
        const logoutDelay = Math.min(10000 * Math.pow(2, Math.min(connectionAttempts, 5)), 300000);
        UltraCleanLogger.info(`üîÑ Restarting in ${Math.round(logoutDelay/1000)}s after logout (attempt ${connectionAttempts})...`);
        setTimeout(async () => {
            await main();
        }, logoutDelay);
        return;
    }
    
    if (statusCode === 409 || statusCode === 440) {
        conflictCount++;
        isConflictRecovery = true;
        if (conflictCount >= 10) {
            UltraCleanLogger.warning(`‚ö†Ô∏è Too many conflicts (${conflictCount}). Waiting 5 minutes before retry to let other sessions settle...`);
            conflictCount = 0;
            setTimeout(async () => {
                await main();
            }, 300000);
            return;
        }
        const conflictDelay = Math.min(8000 + (conflictCount * 5000), 120000);
        UltraCleanLogger.warning(`Device conflict detected (${statusCode}). Attempt ${conflictCount}. Reconnecting in ${Math.round(conflictDelay/1000)}s...`);
        if (conflictCount === 3) {
            UltraCleanLogger.warning(`Multiple conflicts - clearing stale encryption keys...`);
            try {
                const sessionFiles = fs.readdirSync(SESSION_DIR);
                let cleared = 0;
                for (const file of sessionFiles) {
                    if (file.startsWith('sender-key-') || file.startsWith('session-') || 
                        file.startsWith('pre-key-') || file.startsWith('app-state-sync')) {
                        fs.unlinkSync(path.join(SESSION_DIR, file));
                        cleared++;
                    }
                }
                if (cleared > 0) {
                    UltraCleanLogger.info(`üîë Cleared ${cleared} stale signal keys to fix encryption`);
                }
            } catch (cleanErr) {
                UltraCleanLogger.warning(`Signal key cleanup error: ${cleanErr.message}`);
            }
        }
        if (conflictCount >= 5) {
            UltraCleanLogger.warning(`‚ö†Ô∏è Persistent conflict (attempt ${conflictCount}) - another WhatsApp Web/device session may be open. Close other sessions to fix.`);
        }
        setTimeout(async () => {
            await startBot(loginMode, phoneNumber);
        }, conflictDelay);
        return;
    }
    
    if (statusCode === 401 || statusCode === 403) {
        UltraCleanLogger.warning(`Auth error (${statusCode}) detected, cleaning session...`);
        cleanSession();
        const authDelay = Math.min(10000 * Math.pow(2, Math.min(connectionAttempts, 5)), 300000);
        UltraCleanLogger.info(`üîÑ Restarting in ${Math.round(authDelay/1000)}s after auth error (attempt ${connectionAttempts})...`);
        setTimeout(async () => {
            await main();
        }, authDelay);
        return;
    }
    
    const errorMsg = lastDisconnect?.error?.message || '';
    const errorOutput = lastDisconnect?.error?.output?.payload?.message || '';
    const combinedError = `${errorMsg} ${errorOutput}`.toLowerCase();
    
    if (combinedError.includes('decrypt') || combinedError.includes('bad mac') || 
        combinedError.includes('hmac') || statusCode === 515) {
        UltraCleanLogger.warning(`Session decryption error detected (${statusCode}). Clearing signal keys and reconnecting...`);
        try {
            const sessionFiles = fs.readdirSync(SESSION_DIR);
            for (const file of sessionFiles) {
                if (file.startsWith('sender-key-') || file.startsWith('session-') || 
                    file.startsWith('pre-key-') || file.startsWith('app-state-sync')) {
                    fs.unlinkSync(path.join(SESSION_DIR, file));
                }
            }
            UltraCleanLogger.info('Signal keys cleared, keeping creds.json intact');
        } catch (cleanErr) {
            UltraCleanLogger.warning(`Signal key cleanup error: ${cleanErr.message}`);
        }
        setTimeout(async () => {
            await startBot(loginMode, phoneNumber);
        }, 3000);
        return;
    }
    
    const baseDelay = 3000;
    const maxDelay = 30000;
    const delayTime = Math.min(baseDelay * Math.pow(1.5, connectionAttempts - 1), maxDelay);
    
    UltraCleanLogger.info(`üîÑ Reconnecting in ${Math.round(delayTime/1000)}s (attempt ${connectionAttempts})...`);
    
    setTimeout(async () => {
        if (connectionAttempts >= MAX_RETRY_ATTEMPTS) {
            connectionAttempts = 0;
            UltraCleanLogger.critical('Max retry attempts reached. Restarting from scratch...');
            await main();
        } else {
            await startBot(loginMode, phoneNumber);
        }
    }, delayTime);
}

// ====== VIEW-ONCE DETECTION HANDLER ======
function loadAntiViewOnceConfig() {
    try {
        if (_cache_antiviewonce_config) {
            return _cache_antiviewonce_config;
        }
    } catch {}
    return { mode: 'private', ownerJid: '' };
}

function saveAntiViewOnceConfig(config) {
    try {
        _cache_antiviewonce_config = config;
        supabaseDb.setConfig('antiviewonce_config', config).catch(err => {
            console.log('‚ö†Ô∏è Anti-viewonce config save error:', err.message);
        });
    } catch (err) {
        console.log('‚ö†Ô∏è Anti-viewonce config save error:', err.message);
    }
}

function detectViewOnceMedia(rawMessage) {
    if (!rawMessage) return null;

    const mediaTypes = ['imageMessage', 'videoMessage', 'audioMessage'];
    const typeMap = { imageMessage: 'image', videoMessage: 'video', audioMessage: 'audio' };

    // Method 1: Direct viewOnce property on media (WhatsApp current format)
    for (const mt of mediaTypes) {
        if (rawMessage[mt]?.viewOnce) {
            originalConsoleMethods.log(`üîç [AV-DETECT] Found viewOnce via direct property on ${mt}`);
            return { type: typeMap[mt], media: rawMessage[mt], caption: rawMessage[mt].caption || '' };
        }
    }

    // Method 2: viewOnceMessage wrapper (legacy format)
    const voMsg = rawMessage.viewOnceMessage?.message
        || rawMessage.viewOnceMessageV2?.message
        || rawMessage.viewOnceMessageV2Extension?.message;
    if (voMsg) {
        for (const mt of mediaTypes) {
            if (voMsg[mt]) {
                originalConsoleMethods.log(`üîç [AV-DETECT] Found viewOnce via wrapper on ${mt}`);
                return { type: typeMap[mt], media: voMsg[mt], caption: voMsg[mt].caption || '' };
            }
        }
    }

    // Method 3: ephemeralMessage wrapping viewOnce (disappearing messages chat)
    const ephMsg = rawMessage.ephemeralMessage?.message;
    if (ephMsg) {
        const ephResult = detectViewOnceMedia(ephMsg);
        if (ephResult) {
            originalConsoleMethods.log(`üîç [AV-DETECT] Found viewOnce inside ephemeralMessage`);
            return ephResult;
        }
    }

    // Method 4: Use normalizeMessageContent as fallback
    const normalized = normalizeMessageContent(rawMessage);
    if (normalized && normalized !== rawMessage) {
        for (const mt of mediaTypes) {
            if (normalized[mt]?.viewOnce) {
                originalConsoleMethods.log(`üîç [AV-DETECT] Found viewOnce via normalizeMessageContent on ${mt}`);
                return { type: typeMap[mt], media: normalized[mt], caption: normalized[mt].caption || '' };
            }
        }
    }

    return null;
}

async function handleViewOnceDetection(sock, msg) {
    try {
        if (msg.key?.fromMe) return;
        
        const config = loadAntiViewOnceConfig();

        if (config.mode === 'off' || (!config.mode && !config.enabled)) return;

        const ownerJid = config.ownerJid;
        if (!ownerJid && config.mode === 'private') return;

        let rawMessage = msg.message;
        if (!rawMessage) return;

        const normalized = normalizeMessageContent(rawMessage);
        if (normalized) rawMessage = normalized;

        const viewOnce = detectViewOnceMedia(rawMessage);
        if (!viewOnce) return;

        const { type, media, caption } = viewOnce;
        const chatId = msg.key.remoteJid;
        const sender = msg.key.participant || msg.key.remoteJid;
        const senderShort = sender.split('@')[0].split(':')[0];


        const cleanMedia = { ...media };
        delete cleanMedia.viewOnce;

        let buffer;
        const DL_TIMEOUT = 15000;
        try {
            const dlMsg = {
                key: msg.key,
                message: { [`${type}Message`]: cleanMedia }
            };
            buffer = await Promise.race([
                downloadMediaMessage(
                    dlMsg,
                    'buffer',
                    {},
                    {
                        logger: { level: 'silent', trace: () => {}, debug: () => {}, info: () => {}, warn: () => {}, error: () => {}, fatal: () => {}, child: () => ({ level: 'silent', trace: () => {}, debug: () => {}, info: () => {}, warn: () => {}, error: () => {}, fatal: () => {}, child: () => ({}) }) },
                        reuploadRequest: sock.updateMediaMessage
                    }
                ),
                new Promise((_, rej) => setTimeout(() => rej(new Error('dl_timeout')), DL_TIMEOUT))
            ]);
        } catch (dlErr1) {
            try {
                const stream = await Promise.race([
                    downloadContentFromMessage(cleanMedia, type),
                    new Promise((_, rej) => setTimeout(() => rej(new Error('dl_timeout')), DL_TIMEOUT))
                ]);
                const chunks = [];
                for await (const chunk of stream) {
                    chunks.push(chunk);
                    if (chunks.length > 500) break;
                }
                buffer = Buffer.concat(chunks);
            } catch (dlErr2) {
                try {
                    const stream2 = await Promise.race([
                        downloadContentFromMessage(media, type),
                        new Promise((_, rej) => setTimeout(() => rej(new Error('dl_timeout')), DL_TIMEOUT))
                    ]);
                    const chunks2 = [];
                    for await (const chunk of stream2) {
                        chunks2.push(chunk);
                        if (chunks2.length > 500) break;
                    }
                    buffer = Buffer.concat(chunks2);
                } catch (dlErr3) {
                    return;
                }
            }
        }

        if (!buffer || buffer.length === 0) {
            return;
        }

        const sizeKB = Math.round(buffer.length / 1024);
        const timestamp = Date.now();
        const ext = type === 'image' ? 'jpg' : type === 'video' ? 'mp4' : 'mp3';
        const filename = `viewonce_${type}_${senderShort}_${timestamp}.${ext}`;

        const retrievalCaption = await generateRetrievalCaption(sender, 'auto-detect', chatId, null, sock);

        let localConfig = config;
        try {
            const localFile = './data/antiviewonce/config.json';
            if (fs.existsSync(localFile)) {
                const parsed = JSON.parse(fs.readFileSync(localFile, 'utf8'));
                if (parsed && typeof parsed === 'object') localConfig = { ...config, ...parsed };
            }
        } catch {}
        const sendAsSticker = localConfig.sendAsSticker === true && type === 'image';

        const mediaPayload = {};
        if (sendAsSticker) {
            mediaPayload.sticker = buffer;
        } else {
            mediaPayload[type] = buffer;
            mediaPayload.caption = retrievalCaption;
            mediaPayload.fileName = filename;
        }

        if (config.mode === 'public') {
            await sock.sendMessage(chatId, mediaPayload);
        } else {
            const normalizedOwner = jidNormalizedUser(ownerJid);
            await sock.sendMessage(normalizedOwner, mediaPayload);
        }

        try {
            const mimetype = type === 'image' ? 'image/jpeg' : type === 'video' ? 'video/mp4' : 'audio/mpeg';
            await supabaseDb.uploadMedia(filename, buffer, mimetype, 'viewonce');
            _cache_antiviewonce_captured_count++;
        } catch {}

    } catch (error) {
        originalConsoleMethods.log('‚ùå Anti-viewonce error:', error.message, error.stack);
    }
}

// ====== CONNECT COMMAND HANDLER ======
async function handleConnectCommand(sock, msg, args, cleaned) {
    try {
        const chatJid = msg.key.remoteJid || cleaned.cleanJid;
        const start = Date.now();
        const currentPrefix = getCurrentPrefix();
        const prefixDisplay = isPrefixless ? 'none (prefixless)' : `"${currentPrefix}"`;
        const platform = detectPlatform();
        
        const loadingMessage = await sock.sendMessage(chatJid, {
            text: `üê∫ *${BOT_NAME}* is checking connection... ‚ñà‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí`
        }, { quoted: msg });

        const latency = Date.now() - start;
        
        const uptime = process.uptime();
        const hours = Math.floor(uptime / 3600);
        const minutes = Math.floor((uptime % 3600) / 60);
        const seconds = Math.floor(uptime % 60);
        const uptimeText = `${hours}h ${minutes}m ${seconds}s`;
        
        const isOwnerUser = jidManager.isOwner(msg);
        const ultimatefixStatus = isOwnerUser ? '‚úÖ' : '‚ùå';
        
        const memberStats = memberDetector ? memberDetector.getStats() : null;
        
        const antiviewonceStats = antiViewOnceSystem ? antiViewOnceSystem.getStats() : null;
        
        let statusEmoji, statusText, mood;
        if (latency <= 100) {
            statusEmoji = "üü¢";
            statusText = "Excellent";
            mood = "‚ö°Superb Connection";
        } else if (latency <= 300) {
            statusEmoji = "üü°";
            statusText = "Good";
            mood = "üì°Stable Link";
        } else {
            statusEmoji = "üî¥";
            statusText = "Slow";
            mood = "üåëNeeds Optimization";
        }
        
        await sock.sendMessage(chatJid, {
            text: `
‚ï≠‚îÅ‚îÅüåï *CONNECTION STATUS* üåï‚îÅ‚îÅ‚ïÆ
‚îÉ  ‚ö° *User:* ${cleaned.cleanNumber}
‚îÉ  üî¥ *Prefix:* ${prefixDisplay}
‚îÉ  üêæ *Ultimatefix:* ${ultimatefixStatus}
‚îÉ  üèóÔ∏è *Platform:* ${platform}
‚îÉ  ‚è±Ô∏è *Latency:* ${latency}ms ${statusEmoji}
‚îÉ  ‚è∞ *Uptime:* ${uptimeText}
‚îÉ  üë• *Members:* ${memberStats ? `${memberStats.totalEvents} events` : 'Not loaded'}
‚îÉ  üîê *ViewOnce:* ${antiviewonceStats ? `${antiviewonceStats.total} captured` : 'Not loaded'}
‚îÉ  üîó *Status:* ${statusText}
‚îÉ  üéØ *Mood:* ${mood}
‚îÉ  üëë *Owner:* ${isOwnerUser ? '‚úÖ Yes' : '‚ùå No'}
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ
_üê∫ The Moon Watches ‚Äî ..._
`,
            edit: loadingMessage.key
        }, { quoted: msg });
        
        UltraCleanLogger.command(`Connect from ${cleaned.cleanNumber}`);
        
        return true;
    } catch {
        return false;
    }
}

// ====== MESSAGE HANDLER ======

function extractTextFromMessage(messageObj) {
    const content = normalizeMessageContent(messageObj);
    if (!content) return '';
    return content.conversation ||
           content.extendedTextMessage?.text ||
           content.imageMessage?.caption ||
           content.videoMessage?.caption || '';
}

async function handleIncomingMessage(sock, msg) {
    const startTime = Date.now();
    
    try {
        const chatId = msg.key.remoteJid;
        const senderJid = msg.key.participant || chatId;
        
        const isGroup = chatId.includes('@g.us');
        
        if (isGroup && senderJid.includes('@lid')) {
            resolvePhoneFromLid(senderJid);
        }
        
        if (isUserBlocked(senderJid)) {
            return;
        }
        
        try {
            autoLinkSystem.shouldAutoLink(sock, msg).then(linked => {
                if (linked) {
                    UltraCleanLogger.info(`‚úÖ Auto-linking completed for ${senderJid.split('@')[0]}`);
                }
            }).catch(() => {});
        } catch {}
        
        
        try {
            const isOwnerMsg = jidManager.isOwner(msg) || msg.key.fromMe;
            
            const rawMsg = msg.message || {};
            const msgContent = normalizeMessageContent(rawMsg) || rawMsg;
            const isSticker = !!msgContent.stickerMessage;
            const rawText = msgContent.conversation || 
                           msgContent.extendedTextMessage?.text || 
                           msgContent.imageMessage?.caption || '';
            const trimmed = rawText.trim();
            const isEmojiOnly = trimmed.length > 0 && trimmed.length <= 10 && /^[\p{Emoji_Presentation}\p{Emoji}\u200d\ufe0f\s]+$/u.test(trimmed);
            
            if ((isSticker || isEmojiOnly) && isOwnerMsg) {
                const replyCtx = msgContent.stickerMessage?.contextInfo || 
                                msgContent.extendedTextMessage?.contextInfo ||
                                msgContent.imageMessage?.contextInfo ||
                                msgContent.videoMessage?.contextInfo;
                
                if (replyCtx?.quotedMessage) {
                    let quotedMsg = replyCtx.quotedMessage;
                    
                    const viewOnceCheck = detectViewOnceMedia(quotedMsg);
                    
                    if (viewOnceCheck) {
                        const config = loadAntiViewOnceConfig();
                        const ownerJid = config.ownerJid || OWNER_CLEAN_JID;
                        
                        if (ownerJid) {
                            const viewOnce = viewOnceCheck;
                            
                            if (viewOnce) {
                                const { type, media } = viewOnce;
                                const cleanMedia = { ...media };
                                delete cleanMedia.viewOnce;
                                
                                const dlMsg = { 
                                    key: { remoteJid: replyCtx.remoteJid || chatId, id: replyCtx.stanzaId, participant: replyCtx.participant, fromMe: replyCtx.fromMe }, 
                                    message: { [`${type}Message`]: cleanMedia } 
                                };
                                
                                const silentLogger = { level: 'silent', trace: () => {}, debug: () => {}, info: () => {}, warn: () => {}, error: () => {}, fatal: () => {}, child: () => ({ level: 'silent', trace: () => {}, debug: () => {}, info: () => {}, warn: () => {}, error: () => {}, fatal: () => {}, child: () => ({}) }) };
                                
                                try {
                                    const buffer = await Promise.race([
                                        downloadMediaMessage(dlMsg, 'buffer', {}, { logger: silentLogger, reuploadRequest: sock.updateMediaMessage }),
                                        new Promise((_, rej) => setTimeout(() => rej(new Error('dl_timeout')), 15000))
                                    ]);
                                    
                                    if (buffer && buffer.length > 0) {
                                        const normalizedOwner = jidNormalizedUser(ownerJid);
                                        const replierJid = msg.key.participant || msg.key.remoteJid;
                                        const senderJid = replyCtx.participant || replyCtx.remoteJid || chatId;
                                        const replierShort = (replierJid).split('@')[0].split(':')[0];
                                        
                                        const mediaPayload = {};
                                        mediaPayload[type] = buffer;
                                        mediaPayload.caption = await generateRetrievalCaption(senderJid, replierJid, chatId, null, sock);
                                        
                                        await sock.sendMessage(normalizedOwner, mediaPayload);
                                        UltraCleanLogger.info(`üîê View-once auto-captured via ${isSticker ? 'sticker' : 'emoji'} reply from ${replierShort}`);
                                    }
                                } catch (dlErr) {
                                    UltraCleanLogger.warning(`üîê View-once auto-capture failed: ${dlErr.message}`);
                                }
                            }
                        }
                    }
                }
            }
        } catch {}

        try {
            const isOwnerReaction = jidManager.isOwner(msg) || msg.key.fromMe;
            
            const rawMsg = msg.message || {};
            const msgContent2 = normalizeMessageContent(rawMsg) || rawMsg;
            const reactionMsg = msgContent2.reactionMessage;
            
            if (reactionMsg && reactionMsg.key && reactionMsg.text && isOwnerReaction) {
                const reactedKey = reactionMsg.key;
                const reactedMsgId = reactedKey.id;
                const reactedChatId = reactedKey.remoteJid || chatId;
                
                let cachedMsg = getViewOnceFromCache(reactedChatId, reactedMsgId);
                if (!cachedMsg) {
                    cachedMsg = store?.getMessage(reactedChatId, reactedMsgId);
                }
                
                if (cachedMsg) {
                    let viewOnceReactCheck = detectViewOnceMedia(cachedMsg.message || cachedMsg);
                    if (!viewOnceReactCheck) {
                        const cachedContent = normalizeMessageContent(cachedMsg.message || cachedMsg);
                        if (cachedContent) viewOnceReactCheck = detectViewOnceMedia(cachedContent);
                    }
                    
                    if (viewOnceReactCheck) {
                        const config = loadAntiViewOnceConfig();
                        const ownerJid = config.ownerJid || OWNER_CLEAN_JID;
                        
                        if (ownerJid) {
                            const { type, media } = viewOnceReactCheck;
                            const cleanMedia = { ...media };
                            delete cleanMedia.viewOnce;
                            
                            const dlMsg = { 
                                key: { remoteJid: reactedChatId, id: reactedMsgId, participant: reactedKey.participant, fromMe: reactedKey.fromMe }, 
                                message: { [`${type}Message`]: cleanMedia } 
                            };
                            
                            const silentLogger = { level: 'silent', trace: () => {}, debug: () => {}, info: () => {}, warn: () => {}, error: () => {}, fatal: () => {}, child: () => ({ level: 'silent', trace: () => {}, debug: () => {}, info: () => {}, warn: () => {}, error: () => {}, fatal: () => {}, child: () => ({}) }) };
                            
                            try {
                                const buffer = await Promise.race([
                                    downloadMediaMessage(dlMsg, 'buffer', {}, { logger: silentLogger, reuploadRequest: sock.updateMediaMessage }),
                                    new Promise((_, rej) => setTimeout(() => rej(new Error('dl_timeout')), 15000))
                                ]);
                                
                                if (buffer && buffer.length > 0) {
                                    const normalizedOwner = jidNormalizedUser(ownerJid);
                                    const reactorJid2 = msg.key.participant || msg.key.remoteJid;
                                    const reactorShort = (reactorJid2).split('@')[0].split(':')[0];
                                    const senderJid2 = reactedKey.participant || reactedChatId;
                                    const senderShort = senderJid2.split('@')[0].split(':')[0];
                                    
                                    const mediaPayload = {};
                                    mediaPayload[type] = buffer;
                                    mediaPayload.caption = await generateRetrievalCaption(senderJid2, reactorJid2, reactedChatId, null, sock);
                                    
                                    await sock.sendMessage(normalizedOwner, mediaPayload);
                                    UltraCleanLogger.info(`üîê View-once auto-captured via reaction ${reactionMsg.text} from ${reactorShort} on ${senderShort}'s message`);
                                }
                            } catch (dlErr) {
                                UltraCleanLogger.warning(`üîê View-once reaction capture failed: ${dlErr.message}`);
                            }
                        }
                    }
                }
            }
        } catch {}

        const textMsg = extractTextFromMessage(msg.message);
        
        if (!textMsg) return;
        
        const currentPrefix = getCurrentPrefix();
        
        let commandName = '';
        let args = [];
        
        if (!isPrefixless && textMsg.startsWith(currentPrefix)) {
            const spaceIndex = textMsg.indexOf(' ', currentPrefix.length);
            commandName = spaceIndex === -1 
                ? textMsg.slice(currentPrefix.length).toLowerCase().trim()
                : textMsg.slice(currentPrefix.length, spaceIndex).toLowerCase().trim();
            
            args = spaceIndex === -1 ? [] : textMsg.slice(spaceIndex).trim().split(/\s+/);
        } else if (isPrefixless) {
            const words = textMsg.trim().split(/\s+/);
            const firstWord = words[0].toLowerCase();
            
            if (commands.has(firstWord)) {
                commandName = firstWord;
                args = words.slice(1);
            } else {
                for (const [cmdName, command] of commands.entries()) {
                    if (command.alias && command.alias.includes(firstWord)) {
                        commandName = cmdName;
                        args = words.slice(1);
                        break;
                    }
                }
                
                if (!commandName) {
                    const defaultCommands = ['ping', 'help', 'uptime', 'statusstats', 
                                           'ultimatefix', 'prefixinfo',
                                           'antiviewonce', 'av'];
                    if (defaultCommands.includes(firstWord)) {
                        commandName = firstWord;
                        args = words.slice(1);
                    }
                }
            }
        }
        
        if (!commandName) {
            const prefixBypassNames = ['prefix', 'prefixinfo', 'myprefix', 'botprefix'];
            const stripped = textMsg.replace(/^[^a-zA-Z0-9]+/, '').toLowerCase().trim().split(/\s+/)[0];
            if (prefixBypassNames.includes(stripped)) {
                commandName = 'prefixinfo';
                args = [];
            }
        }
        
        if (!commandName) {
            if (isChatbotActiveForChat(chatId)) {
                if (chatId !== 'status@broadcast' && !msg.key.fromMe) {
                    handleChatbotMessage(sock, msg, commands).catch(() => {});
                }
            }
            return;
        }
        
        const rateLimitCheck = rateLimiter.canSendCommand(chatId, senderJid, commandName);
        if (!rateLimitCheck.allowed) {
            await sock.sendMessage(chatId, { 
                text: `‚ö†Ô∏è ${rateLimitCheck.reason}`
            });
            return;
        }
        
        if (senderJid.includes('@lid')) {
            resolvePhoneFromLid(senderJid);
            if (isGroup) {
                resolveSenderFromGroup(senderJid, chatId, sock).catch(() => {});
            }
        }

        const isOwnerUser = jidManager.isOwner(msg);
        let isSudoUser = jidManager.isSudo(msg);
        
        if (!isSudoUser && !isOwnerUser && senderJid.includes('@lid')) {
            const senderRaw = senderJid.split('@')[0].split(':')[0];
            const senderFull = senderJid.split('@')[0];
            let resolvedPhone = lidPhoneCache.get(senderRaw) || lidPhoneCache.get(senderFull) || getPhoneFromLid(senderRaw) || getPhoneFromLid(senderFull);
            
            if (resolvedPhone && isSudoNumber(resolvedPhone)) {
                isSudoUser = true;
                UltraCleanLogger.info(`üîë Sudo detected via LID cache: +${resolvedPhone}`);
            }
        }

        const senderDisplay = getDisplayNumber(senderJid);
        const prefixDisplay = isPrefixless ? '' : currentPrefix;
        const roleTag = isOwnerUser ? 'üëë' : (isSudoUser ? 'üîë' : 'üë§');
        const locationTag = isGroup ? `[${chatId.split('@')[0].substring(0, 10)}]` : '[DM]';
        UltraCleanLogger.command(`${roleTag} ${senderDisplay} ${locationTag} ‚Üí ${prefixDisplay}${commandName} (${Date.now() - startTime}ms)`);

        if (!checkBotMode(msg, commandName, isSudoUser)) {
            if (BOT_MODE === 'silent' && !isOwnerUser && !isSudoUser) {
                return;
            }
            if (!isOwnerUser && !isSudoUser) {
                try {
                    const modeMessages = {
                        'groups': '‚ùå *Command Blocked*\nBot is in *Groups Only* mode. Commands only work in group chats.',
                        'dms': '‚ùå *Command Blocked*\nBot is in *DMs Only* mode. Commands only work in private messages.'
                    };
                    await sock.sendMessage(chatId, { 
                        text: modeMessages[BOT_MODE] || `‚ùå *Command Blocked*\nBot is in ${BOT_MODE} mode.`
                    });
                } catch {
                }
                return;
            }
        }
        
        if (commandName === 'connect' || commandName === 'link') {
            const cleaned = jidManager.cleanJid(senderJid);
            await handleConnectCommand(sock, msg, args, cleaned);
            return;
        }
        
        const command = commands.get(commandName);
        if (command) {
            try {
                if (command.ownerOnly && !isOwnerUser) {
                    const sudoAllowed = command.sudoAllowed !== false;
                    
                    if (sudoAllowed && !isSudoUser && senderJid.includes('@lid')) {
                        try {
                            const sudoTimeout = new Promise((resolve) => setTimeout(() => resolve(false), 3000));
                            isSudoUser = await Promise.race([jidManager.isSudoAsync(msg, sock), sudoTimeout]);
                            if (isSudoUser) {
                                UltraCleanLogger.info(`üîë Sudo confirmed at owner gate via async`);
                            }
                        } catch {}
                    }
                    
                    if (!sudoAllowed || !isSudoUser) {
                        try {
                            await sock.sendMessage(chatId, { 
                                text: '‚ùå *Owner Only Command*'
                            });
                        } catch {
                        }
                        return;
                    }
                }
                
                
                await command.execute(sock, msg, args, currentPrefix, {
                    OWNER_NUMBER: OWNER_CLEAN_NUMBER,
                    OWNER_JID: OWNER_CLEAN_JID,
                    OWNER_LID: OWNER_LID,
                    BOT_NAME,
                    VERSION,
                    isOwner: () => jidManager.isOwner(msg),
                    isSudo: () => isSudoUser || jidManager.isSudo(msg),
                    jidManager,
                    store,
                    statusDetector: statusDetector,
                    updatePrefix: updatePrefixImmediately,
                    getCurrentPrefix: getCurrentPrefix,
                    rateLimiter: rateLimiter,
                    memberDetector: memberDetector,
                    antiViewOnceSystem: antiViewOnceSystem,
                    isPrefixless: isPrefixless,
                    DiskManager: DiskManager
                });
            } catch (error) {
                if (error?.code === 'ENOSPC') {
                    UltraCleanLogger.error(`üíæ Disk full during command ${commandName}! Running emergency cleanup...`);
                    DiskManager.runCleanup(true);
                } else {
                    UltraCleanLogger.error(`Command ${commandName} failed: ${error.message}`);
                }
            }
        } else {
            await handleDefaultCommands(commandName, sock, msg, args, currentPrefix);
        }
    } catch (error) {
        if (error?.code === 'ENOSPC') {
            UltraCleanLogger.error(`üíæ Disk full in message handler! Running emergency cleanup...`);
            DiskManager.runCleanup(true);
        } else {
            UltraCleanLogger.error(`Message handler error: ${error.message}`);
        }
    }
}

// ====== DEFAULT COMMANDS ======
async function handleDefaultCommands(commandName, sock, msg, args, currentPrefix) {
    const chatId = msg.key.remoteJid;
    const isOwnerUser = jidManager.isOwner(msg);
    const ownerInfo = jidManager.getOwnerInfo();
    const prefixDisplay = isPrefixless ? '' : currentPrefix;
    
    try {
        switch (commandName) {
            case 'antiviewonce':
            case 'av': {
                if (!jidManager.isOwner(msg)) {
                    await sock.sendMessage(chatId, {
                        text: '‚ùå *Owner Only Command*'
                    }, { quoted: msg });
                    return;
                }
                
                const avAction = args[0]?.toLowerCase() || 'settings';
                const avOwnerJid = jidNormalizedUser(msg.key.participant || chatId);
                const avConfig = loadAntiViewOnceConfig();
                
                switch (avAction) {
                    case 'private': {
                        const newConfig = { mode: 'private', ownerJid: avOwnerJid, updatedAt: new Date().toISOString() };
                        saveAntiViewOnceConfig(newConfig);
                        await sock.sendMessage(chatId, {
                            text: `‚úÖ *ANTI-VIEWONCE: PRIVATE MODE*\n\n` +
                                 `View-once media will be sent to your DMs:\n` +
                                 `‚Ä¢ Images ‚úÖ\n‚Ä¢ Videos ‚úÖ\n‚Ä¢ Audio ‚úÖ\n\n` +
                                 `üì± Send a view-once message to test!`
                        }, { quoted: msg });
                        break;
                    }
                    case 'public': {
                        const newConfig = { mode: 'public', ownerJid: avOwnerJid, updatedAt: new Date().toISOString() };
                        saveAntiViewOnceConfig(newConfig);
                        await sock.sendMessage(chatId, {
                            text: `‚úÖ *ANTI-VIEWONCE: PUBLIC MODE*\n\n` +
                                 `View-once media will be revealed in the original chat:\n` +
                                 `‚Ä¢ Images ‚úÖ\n‚Ä¢ Videos ‚úÖ\n‚Ä¢ Audio ‚úÖ\n\n` +
                                 `Everyone in the chat can see the media!`
                        }, { quoted: msg });
                        break;
                    }
                    case 'off':
                    case 'disable': {
                        const newConfig = { mode: 'off', ownerJid: avOwnerJid, updatedAt: new Date().toISOString() };
                        saveAntiViewOnceConfig(newConfig);
                        await sock.sendMessage(chatId, {
                            text: '‚ùå *ANTI-VIEWONCE DISABLED*\n\nNo view-once media will be captured.'
                        }, { quoted: msg });
                        break;
                    }
                    case 'on':
                    case 'enable': {
                        const newConfig = { mode: 'private', ownerJid: avOwnerJid, updatedAt: new Date().toISOString() };
                        saveAntiViewOnceConfig(newConfig);
                        await sock.sendMessage(chatId, {
                            text: `‚úÖ *ANTI-VIEWONCE ENABLED (PRIVATE)*\n\n` +
                                 `View-once media will be sent to your DMs:\n` +
                                 `‚Ä¢ Images ‚úÖ\n‚Ä¢ Videos ‚úÖ\n‚Ä¢ Audio ‚úÖ\n\n` +
                                 `Use \`${currentPrefix}av public\` to reveal in chat instead.`
                        }, { quoted: msg });
                        break;
                    }
                    case 'settings':
                    case 'status':
                    case 'check': {
                        const modeDisplay = avConfig.mode === 'private' ? 'üîí Private (Owner DM)' :
                                           avConfig.mode === 'public' ? 'üåê Public (In Chat)' :
                                           '‚ùå Off';
                        let capturedCount = _cache_antiviewonce_captured_count;
                        await sock.sendMessage(chatId, {
                            text: `üîê *ANTI-VIEWONCE SETTINGS*\n\n` +
                                 `*Mode:* ${modeDisplay}\n` +
                                 `*Owner:* ${avConfig.ownerJid ? '‚úÖ Set' : '‚ùå Not set'}\n` +
                                 `*Captured:* ${capturedCount} media files\n\n` +
                                 `*Commands:*\n` +
                                 `\`${currentPrefix}av private\` - Send to owner DM\n` +
                                 `\`${currentPrefix}av public\` - Reveal in chat\n` +
                                 `\`${currentPrefix}av off\` - Disable\n` +
                                 `\`${currentPrefix}av settings\` - This menu`
                        }, { quoted: msg });
                        break;
                    }
                    default:
                        await sock.sendMessage(chatId, {
                            text: `üîê *ANTI-VIEWONCE*\n\n` +
                                 `\`${currentPrefix}av private\` - Send to owner DM\n` +
                                 `\`${currentPrefix}av public\` - Reveal in chat\n` +
                                 `\`${currentPrefix}av off\` - Disable\n` +
                                 `\`${currentPrefix}av settings\` - Check status`
                        }, { quoted: msg });
                }
                break;
            }

            case 'ping':
                const start = Date.now();
                const latency = Date.now() - start;
                
                let statusInfo = '';
                if (statusDetector) {
                    const stats = statusDetector.getStats();
                    statusInfo = `üëÅÔ∏è Status Detector: ‚úÖ ACTIVE\n`;
                    statusInfo += `üìä Detected: ${stats.totalDetected} statuses\n`;
                }
                
                let memberInfo = '';
                if (memberDetector) {
                    const memberStats = memberDetector.getStats();
                    memberInfo = `üë• Member Detector: ‚úÖ ACTIVE\n`;
                    memberInfo += `üìä Events: ${memberStats.totalEvents}\n`;
                }
                
                let antiviewonceInfoPing = '';
                if (antiViewOnceSystem) {
                    const antiviewonceStats = antiViewOnceSystem.getStats();
                    antiviewonceInfoPing = `üîê Anti-ViewOnce: ‚úÖ ACTIVE\n`;
                    antiviewonceInfoPing += `üìä Captured: ${antiviewonceStats.total} media\n`;
                    antiviewonceInfoPing += `üéØ Mode: ${antiviewonceStats.mode}\n`;
                }
                
                await sock.sendMessage(chatId, { 
                    text: `üèì *Pong!*\nLatency: ${latency}ms\nPrefix: "${isPrefixless ? 'none (prefixless)' : currentPrefix}"\nMode: ${BOT_MODE}\nOwner: ${isOwnerUser ? 'Yes ‚úÖ' : 'No ‚ùå'}\n${statusInfo}${memberInfo}${antiviewonceInfoPing}Status: Connected ‚úÖ`
                }, { quoted: msg });
                break;
                
            case 'help':
                let helpText = `üê∫ *${BOT_NAME} HELP*\n\n`;
                helpText += `Prefix: "${isPrefixless ? 'none (prefixless)' : currentPrefix}"\n`;
                helpText += `Mode: ${BOT_MODE}\n`;
                helpText += `Commands: ${commands.size}\n\n`;
                
                helpText += `*PREFIX MANAGEMENT*\n`;
                helpText += `${prefixDisplay}setprefix <new_prefix> - Change prefix (persistent)\n`;
                helpText += `${prefixDisplay}setprefix none - Enable prefixless mode\n`;
                helpText += `${prefixDisplay}prefixinfo - Show prefix information\n\n`;
                
                helpText += `*MEMBER DETECTION*\n`;
                helpText += `${prefixDisplay}members - Show member detection stats\n`;
                helpText += `${prefixDisplay}welcomeset - Configure welcome messages\n\n`;
                
                helpText += `*ANTI-VIEWONCE*\n`;
                helpText += `${prefixDisplay}av private - Send view-once to owner DM\n`;
                helpText += `${prefixDisplay}av public - Reveal view-once in chat\n`;
                helpText += `${prefixDisplay}av off - Disable anti-viewonce\n`;
                helpText += `${prefixDisplay}av settings - Check status\n\n`;
                
                helpText += `*STATUS DETECTOR*\n`;
                helpText += `${prefixDisplay}statusstats - Show status detection stats\n\n`;
                
                for (const [category, cmds] of commandCategories.entries()) {
                    helpText += `*${category.toUpperCase()}*\n`;
                    helpText += `${cmds.slice(0, 6).join(', ')}`;
                    if (cmds.length > 6) helpText += `... (+${cmds.length - 6} more)`;
                    helpText += '\n\n';
                }
                
                await sock.sendMessage(chatId, { text: helpText }, { quoted: msg });
                break;
                
           
            case 'uptime':
                const uptime = process.uptime();
                const hours = Math.floor(uptime / 3600);
                const minutes = Math.floor((uptime % 3600) / 60);
                const seconds = Math.floor(uptime % 60);
                
                let statusDetectorInfo = '';
                if (statusDetector) {
                    const stats = statusDetector.getStats();
                    statusDetectorInfo = `üëÅÔ∏è Status Detector: ‚úÖ ACTIVE\n`;
                    statusDetectorInfo += `üìä Detected: ${stats.totalDetected} statuses\n`;
                    statusDetectorInfo += `üïí Last: ${stats.lastDetection}\n`;
                }
                
                let memberDetectorInfo = '';
                if (memberDetector) {
                    const memberStats = memberDetector.getStats();
                    memberDetectorInfo = `üë• Member Detector: ‚úÖ ACTIVE\n`;
                    memberDetectorInfo += `üìä Events: ${memberStats.totalEvents}\n`;
                    memberDetectorInfo += `üìà Groups: ${memberStats.totalGroups}\n`;
                }
                
                let antiviewonceInfo = '';
                if (antiViewOnceSystem) {
                    const antiviewonceStats = antiViewOnceSystem.getStats();
                    antiviewonceInfo = `üîê Anti-ViewOnce: ‚úÖ ACTIVE\n`;
                    antiviewonceInfo += `üìä Captured: ${antiviewonceStats.total} media\n`;
                    antiviewonceInfo += `üéØ Mode: ${antiviewonceStats.mode}\n`;
                    antiviewonceInfo += `üíæ Size: ${antiviewonceStats.totalSizeKB}KB\n`;
                }
                
                await sock.sendMessage(chatId, {
                    text: `‚è∞ *UPTIME*\n\n${hours}h ${minutes}m ${seconds}s\nüìä Commands: ${commands.size}\nüëë Owner: +${ownerInfo.ownerNumber}\nüí¨ Prefix: "${isPrefixless ? 'none (prefixless)' : currentPrefix}"\nüéõÔ∏è Mode: ${BOT_MODE}\n${statusDetectorInfo}${memberDetectorInfo}${antiviewonceInfo}`
                }, { quoted: msg });
                break;
                
            case 'statusstats':
                if (statusDetector) {
                    const stats = statusDetector.getStats();
                    const recent = statusDetector.statusLogs.slice(-3).reverse();
                    
                    let statsText = `üìä *STATUS DETECTION STATS*\n\n`;
                    statsText += `üîç Status: ‚úÖ ACTIVE\n`;
                    statsText += `üìà Total detected: ${stats.totalDetected}\n`;
                    statsText += `üïí Last detection: ${stats.lastDetection}\n\n`;
                    
                    if (recent.length > 0) {
                        statsText += `üì± *Recent Statuses:*\n`;
                        recent.forEach((status, index) => {
                            statsText += `${index + 1}. ${status.sender}: ${status.type} (${new Date(status.timestamp).toLocaleTimeString()})\n`;
                        });
                    }
                    
                    await sock.sendMessage(chatId, { text: statsText }, { quoted: msg });
                } else {
                    await sock.sendMessage(chatId, { 
                        text: '‚ùå Status detector not initialized.'
                    }, { quoted: msg });
                }
                break;
                
            case 'members':
            case 'memberstats':
                if (memberDetector) {
                    const stats = memberDetector.getStats();
                    
                    let membersText = `üë• *MEMBER DETECTION STATS*\n\n`;
                    membersText += `üîç Status: ${stats.enabled ? '‚úÖ ACTIVE' : '‚ùå DISABLED'}\n`;
                    membersText += `üìà Total events: ${stats.totalEvents}\n`;
                    membersText += `üë• Groups monitored: ${stats.totalGroups}\n`;
                    membersText += `üìä Groups cached: ${stats.cachedGroups}\n\n`;
                    
                    membersText += `üéØ *Features:*\n`;
                    membersText += `‚Ä¢ Auto-detect new members\n`;
                    membersText += `‚Ä¢ Terminal notifications\n`;
                    membersText += `‚Ä¢ Welcome message system\n`;
                    membersText += `‚Ä¢ Profile picture support\n`;
                    
                    await sock.sendMessage(chatId, { text: membersText }, { quoted: msg });
                } else {
                    await sock.sendMessage(chatId, { 
                        text: '‚ùå Member detector not initialized.'
                    }, { quoted: msg });
                }
                break;
                
            case 'welcomeset':
            case 'welcomeconfig':
                const welcomeText = `üéâ *WELCOME SYSTEM CONFIGURATION*\n\n` +
                                  `The welcome system is automatically enabled!\n\n` +
                                  `*How it works:*\n` +
                                  `1. Bot detects new members in groups\n` +
                                  `2. Sends welcome message with profile picture\n` +
                                  `3. Mentions the new member\n` +
                                  `4. Shows terminal notification\n\n` +
                                  `*Default Welcome Message:*\n` +
                                  `"üéâ Welcome {name} to {group}! üéä\n\n` +
                                  `We're now {members} members strong! üí™\n\n` +
                                  `Please read the group rules and enjoy your stay! üòä"\n\n` +
                                  `*Variables:*\n` +
                                  `{name} - Member's name\n` +
                                  `{group} - Group name\n` +
                                  `{members} - Total members\n` +
                                  `{mention} - Mention the member\n\n` +
                                  `*Note:* System runs automatically in background!`;
                
                await sock.sendMessage(chatId, { text: welcomeText }, { quoted: msg });
                break;
        
            case 'ultimatefix':
            case 'solveowner':
            case 'fixall':
                const fixSenderJid = msg.key.participant || chatId;
                const fixCleaned = jidManager.cleanJid(fixSenderJid);
                
                if (!jidManager.isOwner(msg) && !msg.key.fromMe) {
                    await sock.sendMessage(chatId, {
                        text: '‚ùå *Owner Only Command*'
                    }, { quoted: msg });
                    return;
                }
                
                const fixResult = await ultimateFixSystem.applyUltimateFix(sock, fixSenderJid, fixCleaned, false);
                
                if (fixResult.success) {
                    await sock.sendMessage(chatId, {
                        text: `‚úÖ *ULTIMATE FIX APPLIED*\n\nYou should now have full owner access!`
                    }, { quoted: msg });
                } else {
                    await sock.sendMessage(chatId, {
                        text: `‚ùå *Ultimate Fix Failed*`
                    }, { quoted: msg });
                }
                break;
                
            case 'prefixinfo':
                const prefixDbStatus = {
                    'bot_settings (DB)': !!_cache_bot_settings,
                    'prefix_config (DB)': !!_cache_prefix_config
                };
                
                let infoText = `‚ö° *PREFIX INFORMATION*\n\n`;
                infoText += `üìù Current Prefix: *${isPrefixless ? 'none (prefixless)' : currentPrefix}*\n`;
                infoText += `‚öôÔ∏è Default Prefix: ${DEFAULT_PREFIX}\n`;
                infoText += `üåê Global Prefix: ${global.prefix || 'Not set'}\n`;
                infoText += `üìÅ ENV Prefix: ${process.env.PREFIX || 'Not set'}\n`;
                infoText += `üéØ Prefixless Mode: ${isPrefixless ? '‚úÖ ENABLED' : '‚ùå DISABLED'}\n\n`;
                
                infoText += `üìã *Config Status:*\n`;
                for (const [cfgName, loaded] of Object.entries(prefixDbStatus)) {
                    infoText += `‚îú‚îÄ ${cfgName}: ${loaded ? '‚úÖ' : '‚ùå'}\n`;
                }
                
                infoText += `\nüí° *Changes are saved to database and persist after restart!*`;
                
                await sock.sendMessage(chatId, { text: infoText }, { quoted: msg });
                break;
                
            case 'forcerestart':
                if (!jidManager.isOwner(msg)) {
                    await sock.sendMessage(chatId, {
                        text: '‚ùå *Owner Only Command*'
                    }, { quoted: msg });
                    return;
                }
                
                await sock.sendMessage(chatId, {
                    text: 'üîÑ *Initiating forced restart...*\n\nBot will restart in 5 seconds.'
                }, { quoted: msg });
                
                setTimeout(() => {
                    process.exit(1);
                }, 5000);
                break;
        }
    } catch (error) {
        UltraCleanLogger.error(`Default command error: ${error.message}`);
    }
}

// // ====== MAIN APPLICATION ======
// // ====== MAIN APPLICATION ======
// // ====== MAIN APPLICATION ======
// async function main() {
//     try {
//         UltraCleanLogger.success(`üöÄ Starting ${BOT_NAME} v${VERSION} (PREFIXLESS & MEMBER DETECTION & ANTI-VIEWONCE)`);
//         UltraCleanLogger.info(`Loaded prefix: "${isPrefixless ? 'none (prefixless)' : getCurrentPrefix()}"`);
//         UltraCleanLogger.info(`Prefixless mode: ${isPrefixless ? '‚úÖ ENABLED' : '‚ùå DISABLED'}`);
//         UltraCleanLogger.info(`Auto-connect on link: ${AUTO_CONNECT_ON_LINK ? '‚úÖ' : '‚ùå'}`);
//         UltraCleanLogger.info(`Auto-connect on start: ${AUTO_CONNECT_ON_START ? '‚úÖ' : '‚ùå'}`);
//         UltraCleanLogger.info(`Rate limit protection: ${RATE_LIMIT_ENABLED ? '‚úÖ' : '‚ùå'}`);
//         UltraCleanLogger.info(`Console filtering: ‚úÖ ULTRA CLEAN ACTIVE`);
//         UltraCleanLogger.info(`‚ö° Response speed: OPTIMIZED (Reduced delays by 50-70%)`);
//         UltraCleanLogger.info(`üîê Session ID support: ‚úÖ ENABLED (WOLF-BOT: format)`);
//         UltraCleanLogger.info(`üéØ Member Detection: ‚úÖ ENABLED (New members in groups)`);
//         UltraCleanLogger.info(`üîê Anti-ViewOnce: ‚úÖ ENABLED (Private/Auto modes)`);
//         UltraCleanLogger.info(`üë• Welcome System: ‚úÖ ENABLED (Auto-welcome new members)`);
//         UltraCleanLogger.info(`üéØ Background processes: ‚úÖ ENABLED`);

//         // ====== AGGRESSIVE AUTO-RECONNECT LOGIC ======
//         // 1. First try to load existing session directory
//         const sessionDirExists = fs.existsSync(SESSION_DIR);
//         const credsExist = fs.existsSync(path.join(SESSION_DIR, 'creds.json'));
        
//         if (sessionDirExists && credsExist) {
//             UltraCleanLogger.success('üîê Found session directory with creds.json, attempting auto-reconnect...');
            
//             try {
//                 // Try to read the session file
//                 const sessionData = JSON.parse(fs.readFileSync(path.join(SESSION_DIR, 'creds.json'), 'utf8'));
                
//                 // Check for basic required fields (more lenient check)
//                 if (sessionData && (sessionData.noiseKey || sessionData.signedIdentityKey || sessionData.creds)) {
//                     UltraCleanLogger.success('‚úÖ Session file looks valid, auto-connecting...');
//                     await startBot('auto', null);
//                     return;
//                 } else {
//                     UltraCleanLogger.warning('‚ö†Ô∏è Session file exists but may be corrupted');
//                 }
//             } catch (sessionError) {
//                 UltraCleanLogger.error(`‚ùå Error loading session: ${sessionError.message}`);
//             }
//         }
        
//         // 2. Check for SESSION_ID in .env as secondary option
//         const sessionIdFromEnv = process.env.SESSION_ID;
//         const hasEnvSession = sessionIdFromEnv && sessionIdFromEnv.trim() !== '';
        
//         if (hasEnvSession) {
//             UltraCleanLogger.info('üîê Found SESSION_ID in .env, attempting auto-login...');
            
//             try {
//                 const sessionData = parseWolfBotSession(sessionIdFromEnv);
//                 if (sessionData) {
//                     UltraCleanLogger.success('‚úÖ Valid session ID found in .env, auto-connecting...');
//                     await startBot('session', sessionIdFromEnv);
//                     return;
//                 }
//             } catch (error) {
//                 UltraCleanLogger.warning(`‚ùå Session ID validation failed: ${error.message}`);
//             }
//         }
        
//         // 3. If no session found, check if we should attempt pairing with saved phone
//         const ownerFileExists = fs.existsSync(OWNER_FILE);
//         if (ownerFileExists) {
//             try {
//                 const ownerData = JSON.parse(fs.readFileSync(OWNER_FILE, 'utf8'));
//                 if (ownerData.OWNER_NUMBER) {
//                     UltraCleanLogger.info(`üì± Found saved owner number: ${ownerData.OWNER_NUMBER}, attempting to reconnect...`);
                    
//                     // Try to reconnect with saved phone number
//                     await startBot('pair', ownerData.OWNER_NUMBER);
//                     return;
//                 }
//             } catch (error) {
//                 UltraCleanLogger.warning(`Could not load owner data: ${error.message}`);
//             }
//         }
        
//         // 4. If all else fails, show login options
//         UltraCleanLogger.info('üì± No valid session found, showing login options...');
//         const loginManager = new LoginManager();
//         const loginInfo = await loginManager.selectMode();
//         loginManager.close();
        
//         const loginData = loginInfo.mode === 'session' ? loginInfo.sessionId : loginInfo.phone;
//         await startBot(loginInfo.mode, loginData);
        
//     } catch (error) {
//         UltraCleanLogger.error(`Main error: ${error.message}`);
//         setTimeout(async () => {
//             await main();
//         }, 8000);
//     }
// }







// ====== MAIN APPLICATION ======
// ====== MAIN APPLICATION ======
async function main() {
    try {
        UltraCleanLogger.success(`üöÄ Starting ${BOT_NAME} v${VERSION} (PREFIXLESS & MEMBER DETECTION & ANTI-VIEWONCE)`);
        
        // ====== HEROKU INITIALIZATION ======
        UltraCleanLogger.info(`üåê Environment: ${process.env.NODE_ENV || 'production'}`);
        UltraCleanLogger.info(`üîß Platform: ${detectPlatform()}`);
        
        // Initialize Heroku systems
        setupHerokuHealthCheck();
        setupHerokuKeepAlive();
        
        // ====== HEROKU DETECTION & SETUP ======
        //const isHeroku = process.env.HEROKU || process.env.DYNO || false;
        // ====== HEROKU DETECTION & SETUP ======
const isHeroku = process.env.HEROKU_APP_NAME || process.env.DYNO || process.env.HEROKU_API_KEY || false;
        const herokuSessionId = process.env.SESSION_ID;
        
        if (isHeroku) {
            UltraCleanLogger.info(`üèóÔ∏è Platform: Heroku`);
            UltraCleanLogger.info(`üì¶ Dyno: ${process.env.DYNO || 'Unknown'}`);
            
            // Check if we have SESSION_ID from Heroku Config Vars
            if (herokuSessionId && herokuSessionId.trim() !== '') {
                UltraCleanLogger.success('üîê Heroku SESSION_ID detected');
                
                // Setup Heroku session automatically
                const herokuSetupSuccess = setupHerokuSession();
                
                if (herokuSetupSuccess) {
                    UltraCleanLogger.success('‚úÖ Heroku session configured successfully');
                    UltraCleanLogger.info('üîÑ Starting bot with Heroku session...');
                    
                    // Auto-start with Heroku session
                    await startBot('auto', null);
                    return;
                } else {
                    UltraCleanLogger.warning('‚ö†Ô∏è Heroku session setup failed, falling back to normal login');
                }
            } else {
                UltraCleanLogger.warning('‚ö†Ô∏è Heroku detected but no SESSION_ID found');
                UltraCleanLogger.info('üí° Add SESSION_ID to Heroku Config Vars for auto-login');
            }
        }
        
        // Show bot features
        UltraCleanLogger.info(`Loaded prefix: "${isPrefixless ? 'none (prefixless)' : getCurrentPrefix()}"`);
        UltraCleanLogger.info(`Prefixless mode: ${isPrefixless ? '‚úÖ ENABLED' : '‚ùå DISABLED'}`);
        UltraCleanLogger.info(`Auto-connect on link: ${AUTO_CONNECT_ON_LINK ? '‚úÖ' : '‚ùå'}`);
        UltraCleanLogger.info(`Auto-connect on start: ${AUTO_CONNECT_ON_START ? '‚úÖ' : '‚ùå'}`);
        UltraCleanLogger.info(`Rate limit protection: ${RATE_LIMIT_ENABLED ? '‚úÖ' : '‚ùå'}`);
        UltraCleanLogger.info(`Console filtering: ‚úÖ ULTRA CLEAN ACTIVE`);
        UltraCleanLogger.info(`‚ö° Response speed: OPTIMIZED (Reduced delays by 50-70%)`);
        UltraCleanLogger.info(`üîê Session ID support: ‚úÖ ENABLED (WOLF-BOT: format)`);
        UltraCleanLogger.info(`üéØ Member Detection: ‚úÖ ENABLED (New members in groups)`);
        UltraCleanLogger.info(`üîê Anti-ViewOnce: ‚úÖ ENABLED (Private/Auto modes)`);
        UltraCleanLogger.info(`üë• Welcome/Goodbye System: ‚úÖ AVAILABLE (Off by default, enable per-group)`);
        UltraCleanLogger.info(`üéØ Background processes: ‚úÖ ENABLED`);
        DiskManager.start();
        
        // ====== AUTO-RECONNECT LOGIC ======
        // 1. First try SESSION_ID from .env (works on any platform)
        const sessionIdFromEnv = process.env.SESSION_ID;
        const hasEnvSession = sessionIdFromEnv && sessionIdFromEnv.trim() !== '';
        
        const sessionDirExists = fs.existsSync(SESSION_DIR);
        const credsPath = path.join(SESSION_DIR, 'creds.json');
        const credsExist = fs.existsSync(credsPath);

        if (sessionDirExists && credsExist) {
            try {
                const existingCreds = JSON.parse(fs.readFileSync(credsPath, 'utf8'));
                if (existingCreds && (existingCreds.noiseKey || existingCreds.signedIdentityKey)) {
                    UltraCleanLogger.success('üîê Found existing evolved session, using it (not overwriting with SESSION_ID)...');
                    await startBot('auto', null);
                    return;
                }
            } catch (readErr) {
                UltraCleanLogger.warning(`‚ö†Ô∏è Existing creds.json unreadable: ${readErr.message}`);
            }
        }

        if (hasEnvSession) {
            UltraCleanLogger.info('üîê No valid existing session, applying SESSION_ID...');
            try {
                const parsedSession = parseWolfBotSession(sessionIdFromEnv);
                if (parsedSession) {
                    ensureSessionDir();
                    fs.writeFileSync(credsPath, JSON.stringify(parsedSession, null, 2));
                    UltraCleanLogger.success('‚úÖ Session ID applied to creds.json, auto-connecting...');
                    await startBot('auto', null);
                    return;
                }
            } catch (error) {
                UltraCleanLogger.warning(`‚ö†Ô∏è SESSION_ID parsing failed: ${error.message}`);
            }
        }
        
        // 3. Fallback: try existing session that might have creds but no noise/signal keys
        if (sessionDirExists && credsExist) {
            UltraCleanLogger.success('üîê Found existing session, attempting auto-reconnect...');
            
            try {
                const sessionData = JSON.parse(fs.readFileSync(credsPath, 'utf8'));
                
                if (sessionData && (sessionData.noiseKey || sessionData.signedIdentityKey || sessionData.creds)) {
                    UltraCleanLogger.success('‚úÖ Session file valid, auto-connecting...');
                    await startBot('auto', null);
                    return;
                } else {
                    UltraCleanLogger.warning('‚ö†Ô∏è Session file exists but may be corrupted');
                }
            } catch (sessionError) {
                UltraCleanLogger.error(`‚ùå Error loading session: ${sessionError.message}`);
            }
        }
        
        // 3. Check for saved owner number to attempt pairing
        if (_cache_owner_data) {
            try {
                const ownerData = _cache_owner_data;
                if (ownerData.OWNER_NUMBER) {
                    UltraCleanLogger.info(`üì± Found saved owner number: ${ownerData.OWNER_NUMBER}, attempting to reconnect...`);
                    await startBot('pair', ownerData.OWNER_NUMBER);
                    return;
                }
            } catch (error) {
                UltraCleanLogger.warning(`Could not load owner data: ${error.message}`);
            }
        }
        
        // 4. If all else fails, show login options (skip on Heroku)
        if (isHeroku) {
            UltraCleanLogger.error('‚ùå Heroku deployment failed: No valid session found');
            UltraCleanLogger.info('üí° Please add a valid SESSION_ID to Heroku Config Vars');
            setInterval(() => {
                UltraCleanLogger.warning('‚è≥ Waiting for valid session configuration...');
            }, 30000);
            return;
        }
        
        // 5. Show login options for interactive environments
        UltraCleanLogger.info('üì± No valid session found, showing login options...');
        const loginManager = new LoginManager();
        const loginInfo = await loginManager.selectMode();
        loginManager.close();
        
        const loginData = loginInfo.mode === 'session' ? loginInfo.sessionId : loginInfo.phone;
        await startBot(loginInfo.mode, loginData);
        
    } catch (error) {
        UltraCleanLogger.error(`Main error: ${error.message}`);
        
        // Handle restarts based on platform
        if (process.env.HEROKU) {
            // Longer delay on Heroku to avoid rapid restarts
            UltraCleanLogger.warning('üîÑ Heroku restart scheduled in 30 seconds...');
            setTimeout(async () => {
                await main();
            }, 30000);
        } else {
            // Faster restart for local/panel deployments
            UltraCleanLogger.warning('üîÑ Restarting in 8 seconds...');
            setTimeout(async () => {
                await main();
            }, 8000);
        }
    }
}
// ====== PROCESS HANDLERS ======
process.on('SIGINT', () => {
    console.log(chalk.yellow('\nüëã Shutting down gracefully...'));
    stopHeartbeat();
    memoryMonitor.stop();
    
    if (SOCKET_INSTANCE) SOCKET_INSTANCE.ws.close();
    process.exit(0);
});

process.on('uncaughtException', (error) => {
    UltraCleanLogger.error(`Uncaught exception: ${error.message}`);
    UltraCleanLogger.error(error.stack);
});

process.on('unhandledRejection', (error) => {
    UltraCleanLogger.error(`Unhandled rejection: ${error.message}`);
});

// Start the bot
main().catch((error) => {
    UltraCleanLogger.critical(`Fatal error: ${error.message}`);
    process.exit(1);
});













